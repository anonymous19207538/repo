{"domain": [{"api": "security.service.SecurityServiceImpl.check", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # Regex to check UUID format\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Check 1: Format Check for accountId\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Check 2: Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match user_id in the environment\"\n    \n    # Check 3: Related Events Check\n    related_event = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"]\n    assert log[\"arguments\"][\"accountId\"] == related_event[\"arguments\"][\"accountId\"], \"accountId should match the accountId in the related event arguments\"\n    \n    candidate_account_ids = [contact[\"accountId\"] for contact in related_event[\"response\"][\"data\"]]\n    assert log[\"arguments\"][\"accountId\"] in candidate_account_ids, \"accountId should be one of the accountId fields in the related event data\"\n    \n    # Check 4: Argument and Database Status Check\n    assert related_event[\"response\"][\"status\"] == 1, \"status should be 1 in the related event response\"  # Past status feedback: 1\n\n    # Check 5: Vulnerability Check\n    # Although not present in the example, if we had fields such as comments or notes, we should check for SQL injection\n    # Since this example doesn't have such fields, this check is more of a placeholder for future use.\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    datetime_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$\")\n    # Modified float regex to allow negative floats\n    float_re = re.compile(r\"^-?\\d+(\\.\\d+)?$\")\n    \n    order = log[\"arguments\"][\"order\"]\n    \n    assert uuid_re.match(order[\"id\"]), \"order.id should be a UUID\"\n    assert date_re.match(order[\"boughtDate\"]) or datetime_re.match(order[\"boughtDate\"]), \"order.boughtDate should be a date or datetime\"\n    assert date_re.match(order[\"travelDate\"]), \"order.travelDate should be a date\"\n    assert datetime_re.match(order[\"travelTime\"]), \"order.travelTime should be a datetime\"\n    assert float_re.match(order[\"price\"]), \"order.price should be a float format\"\n    \n    assert isinstance(order[\"coachNumber\"], int) and order[\"coachNumber\"] > 0, \"order.coachNumber should be a positive integer\"\n    assert isinstance(order[\"seatClass\"], int) and order[\"seatClass\"] > 0, \"order.seatClass should be a positive integer\"\n    assert isinstance(order[\"status\"], int) and order[\"status\"] >= 0, \"order.status should be a non-negative integer\"\n    \n    assert not SQL_INJECTION_RE.search(order[\"contactsName\"]), \"contactsName should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"from\"]), \"from should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"to\"]), \"to should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"trainNumber\"]), \"trainNumber should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"seatNumber\"]), \"seatNumber should not contain SQL injection features\"\n\n    assert order[\"accountId\"] == log[\"env\"][\"user_id\"], \"order.accountId should match env.user_id\"\n    \n    related_data = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    matching_contacts = [contact for contact in related_data if contact[\"accountId\"] == order[\"accountId\"]]\n    \n    assert any(contact[\"documentNumber\"] == order[\"contactsDocumentNumber\"] and contact[\"documentType\"] == order[\"documentType\"] for contact in matching_contacts), \"contactsDocumentNumber and documentType should match with the provided accountId\"\n    \n    response_status = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"status\"]\n    assert response_status == 1, \"Past status Feedback: 1. response.status should be 1 for success\"\n\n    assert log[\"env\"][\"user_id\"] == log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"env\"][\"user_id\"], \"env.user_id should match related_events env.user_id\"\n    assert log[\"env\"][\"is_user\"] == log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"env\"][\"is_user\"], \"env.is_user should match related_events env.is_user\"\n    assert log[\"env\"][\"is_admin\"] == log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"env\"][\"is_admin\"], \"env.is_admin should match related_events env.is_admin\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "inside_payment.service.InsidePaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    # Precompiled regex for SQL injection check\n    SQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n    \n    # Check userId only if it's not None, otherwise skip its specific checks\n    userId = log[\"arguments\"][\"info\"].get(\"userId\")\n    if userId is not None:\n        # Environment integrity check: userId in arguments should match user_id in env\n        assert userId == log[\"env\"][\"user_id\"], \"userId in arguments should match user_id in env\"\n        \n        # Check for SQL injection in userId\n        assert not SQL_INJECTION_RE.search(userId), \"userId should not contain SQL injection features\"\n    \n    # Validate orderId and tripId fields are not None and are strings\n    for field in [\"orderId\", \"tripId\"]:\n        assert log[\"arguments\"][\"info\"][field] is not None, f\"{field} should not be None\"\n        assert isinstance(log[\"arguments\"][\"info\"][field], str), f\"{field} should be a string\"\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][field]), f\"{field} should not contain SQL injection features\"\n\n    # Related events check: Ensure accountId matches userId if userId is provided\n    if userId is not None:\n        related_orders = log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"data\"]\n        related_orders_for_refresh = log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"]\n        other_related_orders = log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"data\"]\n        other_related_orders_for_refresh = log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"]\n        \n        all_related_orders = related_orders + related_orders_for_refresh + other_related_orders + other_related_orders_for_refresh\n\n        user_ids_in_related_orders = {order[\"accountId\"] for order in all_related_orders}\n        assert userId in user_ids_in_related_orders, \"userId in arguments should be one of the accountId in related events response data\"\n\n    # Price consistency check if price is not None\n    price = log[\"arguments\"][\"info\"].get(\"price\")\n    if price is not None:\n        assert isinstance(price, str), \"price should be a string\"\n        assert not SQL_INJECTION_RE.search(price), \"price should not contain SQL injection features\"\n        \n        # Price in arguments should match price in related orders\n        prices_in_related_orders = {order[\"price\"] for order in all_related_orders}\n        assert price in prices_in_related_orders, \"price in arguments should match price in related orders\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    alphanumeric_hyphen_re = re.compile(r\"^[a-zA-Z0-9-]+$\")\n    assert alphanumeric_hyphen_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be alphanumeric with hyphens\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n\n    # Collect related accountIds and orderIds from related events\n    related_account_ids = set()\n    related_order_ids = set()\n    \n    for event_name, event_data in log[\"related_events\"].items():\n        if event_data is not None:\n            response_data = event_data.get(\"response\", {}).get(\"data\")\n            if response_data:\n                for order in response_data:\n                    related_account_ids.add(order[\"accountId\"])\n                    related_order_ids.add(order[\"id\"])\n    \n    # Database integrity Check\n    if related_order_ids:\n        assert log[\"arguments\"][\"orderId\"] in related_order_ids, \"orderId should match one of the id fields in the related events' response data\"\n\n    # Environment integrity check\n    if related_account_ids:\n        assert log[\"env\"][\"user_id\"] in related_account_ids, \"user_id in env should match one of the accountId fields in the related events' response data\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\n    # Check if accountId is a UUID\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Check if accountId matches user_id in env\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in the env object\"\n\n    # Check if is_user is a boolean value\n    assert isinstance(log[\"env\"][\"is_user\"], bool), \"is_user should be a boolean value\"\n\n    # Check if is_admin is a boolean value\n    assert isinstance(log[\"env\"][\"is_admin\"], bool), \"is_admin should be a boolean value\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"]\n    qi = arguments[\"qi\"]\n    env = log[\"env\"]\n    related_events = log.get(\"related_events\", {})\n    \n    # Format Check\n    assert isinstance(arguments[\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(qi[\"loginId\"], str), \"loginId should be a string\"\n    assert isinstance(qi[\"state\"], int), \"state should be an integer\"\n    assert isinstance(qi[\"enableBoughtDateQuery\"], (int, bool)), \"enableBoughtDateQuery should be an integer or boolean\"\n    assert isinstance(qi[\"enableStateQuery\"], (int, bool)), \"enableStateQuery should be an integer or boolean\"\n    assert isinstance(qi[\"enableTravelDateQuery\"], (int, bool)), \"enableTravelDateQuery should be an integer or boolean\"\n    \n    # Vulnerability Check\n    for field in [arguments[\"accountId\"], qi[\"loginId\"]]:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain any SQL injection features\"\n\n    # Range Check\n    for field in [\"enableBoughtDateQuery\", \"enableStateQuery\", \"enableTravelDateQuery\"]:\n        assert qi[field] in [0, 1, False, True], f\"{field} should be either 0, 1, False, or True\"\n    \n    # Argument and Database Status Check\n    # Past status feedback: [0, 1]\n    assert qi[\"state\"] in [0, 1], \"state should be 0 or 1\"  # Past status feedback\n    \n    # Database Integrity Check (use related events)\n    for event_name, event in related_events.items():\n        if event is not None and isinstance(event, dict):\n            event_arguments = event.get(\"arguments\")\n            if event_arguments and isinstance(event_arguments, dict):\n                event_qi = event_arguments.get(\"qi\")\n                if event_qi and isinstance(event_qi, dict):\n                    assert arguments[\"accountId\"] == event_arguments[\"accountId\"], f\"accountId should match in related event {event_name}\"\n                    assert qi[\"loginId\"] == event_qi[\"loginId\"], f\"loginId should match in related event {event_name}\"\n\n    # Environment Integrity Check\n    assert arguments[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n    \n    # Related Events Check\n    all_related_account_ids = [\n        item[\"accountId\"] \n        for event in related_events.values()\n        if isinstance(event, dict) and \"response\" in event and \"data\" in event[\"response\"]\n        for item in event[\"response\"][\"data\"]\n    ]\n    assert arguments[\"accountId\"] in all_related_account_ids, \"accountId should be one of the accountIds in related events responses\"\n\n    # Environment Database Integrity Check\n    for event_name, event in related_events.items():\n        if event and isinstance(event, dict) and \"env\" in event:\n            assert env[\"user_id\"] == event[\"env\"][\"user_id\"], f\"user_id should match in related event {event_name}\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # 1. Format Check: Ensure the \"id\" field in the \"arguments\" follows the UUID format.\n    assert uuid_re.match(log[\"arguments\"][\"id\"]), \"id should be a UUID\"\n    \n    # 2. SQL Injection Check: Ensure the \"id\" field in the \"arguments\" does not contain any SQL injection features.\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"id\"]), \"id should not contain any SQL injection features\"\n    \n    # 3. Database Integrity Check: Verify that the \"id\" in the \"arguments\" is consistent with the \"id\" field in the related events response data.\n    related_event_data = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    candidate_ids = [item[\"id\"] for item in related_event_data]\n    assert log[\"arguments\"][\"id\"] in candidate_ids, \"id should be one of the id fields in the related events response data\"\n    \n    # 4. Environment Integrity Check: Verify that the \"user_id\" field in the \"env\" matches the \"accountId\" field in the related events arguments.\n    related_event_args = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"arguments\"]\n    assert log[\"env\"][\"user_id\"] == related_event_args[\"accountId\"], \"user_id should match the accountId in the related events arguments\"\n    \n    # 5. Argument and Database Status Check: Verify that the \"status\" field in the related events response is 1 (past status feedback).\n    related_event_response = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"]\n    assert related_event_response[\"status\"] == 1, \"status in the related events response should be 1\"  # Past status feedback: 1\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "user.service.impl.UserServiceImpl.findByUserId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"userId\"]), \"userId should be a UUID\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"userId\"] == log[\"env\"][\"user_id\"], \"userId in arguments should match user_id in env\"\n    \n    # Related Events Check\n    related_event_key = \"contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if related_event_key in log[\"related_events\"]:\n        related_event = log[\"related_events\"][related_event_key]\n        if related_event and isinstance(related_event, dict) and \"arguments\" in related_event and \"accountId\" in related_event[\"arguments\"]:\n            assert log[\"arguments\"][\"userId\"] == related_event[\"arguments\"][\"accountId\"], \"userId in arguments should match accountId in related_events\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"userId\"]), \"userId should not contain any SQL injection features\"\n    \n    # Environment Database Integrity Check\n    if related_event_key in log[\"related_events\"]:\n        related_event = log[\"related_events\"][related_event_key]\n        if related_event and isinstance(related_event, dict) and \"env\" in related_event and \"user_id\" in related_event[\"env\"]:\n            assert log[\"env\"][\"user_id\"] == related_event[\"env\"][\"user_id\"], \"user_id in env should match user_id in related_events env\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.queryByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    accountId = log[\"arguments\"][\"accountId\"]\n    \n    # Format Check: UUID for accountId\n    assert UUID_RE.match(accountId), \"accountId should be a UUID\"\n    \n    # Environment Integrity Check\n    assert accountId == log[\"env\"][\"user_id\"], \"accountId should match env user_id\"\n\n    # Related Events Check\n    related_events = log.get(\"related_events\", {})\n    \n    # Check against contacts.service.ContactsServiceImpl.findContactsByAccountId\n    contacts_event = related_events.get(\"contacts.service.ContactsServiceImpl.findContactsByAccountId\")\n    if contacts_event:\n        assert accountId == contacts_event[\"arguments\"][\"accountId\"], \"accountId should match in contacts event arguments\"\n        candidate_accountIds = [data[\"accountId\"] for data in contacts_event[\"response\"][\"data\"]]\n        assert accountId in candidate_accountIds, \"accountId should be in contacts response data\"\n    \n    # Check against other.service.OrderOtherServiceImpl.queryOrders\n    orders_event = related_events.get(\"other.service.OrderOtherServiceImpl.queryOrders\")\n    if orders_event:\n        assert accountId == orders_event[\"arguments\"][\"accountId\"], \"accountId should match in orders event arguments\"\n        candidate_accountIds_orders = [data[\"accountId\"] for data in orders_event[\"response\"][\"data\"]]\n        assert accountId in candidate_accountIds_orders, \"accountId should be in orders response data\"\n    \n    # Check against other.service.OrderOtherServiceImpl.queryOrdersForRefresh\n    orders_refresh_event = related_events.get(\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\")\n    if orders_refresh_event:\n        assert accountId == orders_refresh_event[\"arguments\"][\"accountId\"], \"accountId should match in orders for refresh event arguments\"\n        candidate_accountIds_orders_refresh = [data[\"accountId\"] for data in orders_refresh_event[\"response\"][\"data\"]]\n        assert accountId in candidate_accountIds_orders_refresh, \"accountId should be in orders for refresh response data\"\n\n    # Vulnerability Check\n    def check_for_injection(d):\n        for key, value in d.items():\n            if isinstance(value, str) and SQL_INJECTION_RE.search(value):\n                raise AssertionError(f\"{key} contains SQL injection patterns\")\n            elif isinstance(value, dict):\n                check_for_injection(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if isinstance(item, dict):\n                        check_for_injection(item)\n\n    check_for_injection(log[\"arguments\"])\n    check_for_injection(log[\"env\"])\n    check_for_injection(log[\"related_events\"])\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\")\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")  # Basic check for ISO date format YYYY-MM-DD\n    numeric_re = re.compile(r\"^\\d+(\\.\\d{1,2})?$\")  # Check for numeric values with up to two decimal places\n\n    # Check format for accountId and loginId\n    accountId = log[\"arguments\"][\"accountId\"]\n    loginId = log[\"arguments\"][\"qi\"][\"loginId\"]\n\n    assert uuid_re.match(accountId), \"accountId should be a UUID\"\n    assert uuid_re.match(loginId), \"loginId should be a UUID\"\n\n    # Check for SQL injection in string fields\n    assert not SQL_INJECTION_RE.search(accountId), \"accountId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(loginId), \"loginId should not contain SQL injection features\"\n\n    # Range Check for boolean-like integer fields\n    assert log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"] in [0, 1], \"enableTravelDateQuery should be 0 or 1\"\n    assert log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"] in [0, 1], \"enableBoughtDateQuery should be 0 or 1\"\n    assert log[\"arguments\"][\"qi\"][\"enableStateQuery\"] in [0, 1], \"enableStateQuery should be 0 or 1\"\n\n    # Argument and Database Status Check\n    # Initial status guess for `state`\n    assert log[\"arguments\"][\"qi\"][\"state\"] in [0, 1, 2], \"state should be within expected values\"  # Initial status guess: [0, 1, 2]\n\n    # Environment Integrity Check\n    assert accountId == log[\"env\"][\"user_id\"], \"accountId should match user_id in env\"\n\n    # Related Events Check\n    def accountIdInRelatedEvents():\n        for event_key, event in log[\"related_events\"].items():\n            if accountId == event[\"arguments\"][\"accountId\"]:\n                return True\n        return False\n    \n    assert accountIdInRelatedEvents(), \"accountId should be one of the accountId fields in the related events arguments\"\n\n    # Environment Database Integrity Check\n    assert loginId == log[\"env\"][\"user_id\"], \"loginId should match user_id in env\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nDATE_TIME_FORMAT = \"%Y-%m-%d %H:%M:%S\"\nDATE_FORMAT = \"%Y-%m-%d\"\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    env = log[\"env\"]\n    related_events = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"]\n    contact_data = related_events[\"response\"][\"data\"]\n\n    # Format Check\n    assert UUID_RE.match(order[\"id\"]), \"Order ID should be a UUID\"\n    assert UUID_RE.match(order[\"accountId\"]), \"Account ID should be a UUID\"\n    \n    try:\n        datetime.strptime(order[\"boughtDate\"], DATE_TIME_FORMAT)\n    except ValueError:\n        raise AssertionError(\"boughtDate should be in YYYY-MM-DD HH:MM:SS format\")\n        \n    try:\n        datetime.strptime(order[\"travelDate\"], DATE_FORMAT)\n    except ValueError:\n        raise AssertionError(\"travelDate should be in YYYY-MM-DD format\")\n        \n    try:\n        datetime.strptime(order[\"travelTime\"], DATE_TIME_FORMAT)\n    except ValueError:\n        raise AssertionError(\"travelTime should be in YYYY-MM-DD HH:MM:SS format\")\n\n    # Vulnerability Check\n    for key, value in order.items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain SQL injection features\"\n\n    # Range Check\n    assert isinstance(order[\"documentType\"], int) and order[\"documentType\"] >= 0, \"documentType should be a non-negative integer\"\n    assert isinstance(order[\"coachNumber\"], int) and order[\"coachNumber\"] > 0, \"coachNumber should be a positive integer\"\n    assert isinstance(order[\"seatClass\"], int) and order[\"seatClass\"] > 0, \"seatClass should be a positive integer\"\n\n    # Argument and Database Status Check\n    assert order[\"status\"] == 0, \"Order status should be 0\"  # Initial status guess: 0\n\n    # Database Integrity Check\n    assert order[\"accountId\"] == related_events[\"arguments\"][\"accountId\"], \"AccountId should match related event accountId\"\n\n    contact_matches = [cd for cd in contact_data if cd[\"documentNumber\"] == order[\"contactsDocumentNumber\"] and cd[\"documentType\"] == order[\"documentType\"]]\n    assert contact_matches, \"contactsDocumentNumber and documentType should match any entry in related_events\"\n\n    # Environment Integrity Check\n    assert order[\"accountId\"] == env[\"user_id\"], \"AccountId should match user_id in environment\"\n\n    # Related Events Check\n    account_ids = {cd[\"accountId\"] for cd in contact_data}\n    assert order[\"accountId\"] in account_ids, \"AccountId should be one of the accountId entries in related_events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert UUID_RE.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID format\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Environment Integrity Check\n    query_orders = log.get(\"related_events\", {}).get(\"other.service.OrderOtherServiceImpl.queryOrders\")\n    if query_orders:\n        arguments = query_orders.get(\"arguments\", {})\n        qi = arguments.get(\"qi\")\n        if qi and \"loginId\" in qi:\n            assert log[\"env\"][\"user_id\"] == qi[\"loginId\"], \"user_id should match loginId in queryOrders\"\n        \n    query_orders_refresh = log.get(\"related_events\", {}).get(\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\")\n    if query_orders_refresh:\n        arguments = query_orders_refresh.get(\"arguments\", {})\n        qi = arguments.get(\"qi\")\n        if qi and \"loginId\" in qi:\n            assert log[\"env\"][\"user_id\"] == qi[\"loginId\"], \"user_id should match loginId in queryOrdersForRefresh\"\n    \n    # Related Events Check\n    if query_orders:\n        data = query_orders.get(\"response\", {}).get(\"data\", [])\n        order_ids_query = [entry[\"id\"] for entry in data]\n        assert log[\"arguments\"][\"orderId\"] in order_ids_query, \"orderId should be present in queryOrders data\"\n    \n    if query_orders_refresh:\n        data = query_orders_refresh.get(\"response\", {}).get(\"data\", [])\n        order_ids_refresh = [entry[\"id\"] for entry in data]\n        assert log[\"arguments\"][\"orderId\"] in order_ids_refresh, \"orderId should be present in queryOrdersForRefresh data\"\n    \n    # Environment Database Integrity Check\n    if query_orders:\n        query_env = query_orders.get(\"env\", {})\n        assert log[\"env\"][\"is_admin\"] == query_env.get(\"is_admin\"), \"env is_admin should be consistent across events\"\n        assert log[\"env\"][\"is_user\"] == query_env.get(\"is_user\"), \"env is_user should be consistent across events\"\n        assert log[\"env\"][\"user_id\"] == query_env.get(\"user_id\"), \"env user_id should be consistent across events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consignprice.service.ConsignPriceServiceImpl.getPriceByWeightAndRegion", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Check if weight is a float and greater than 0\n    assert isinstance(log[\"arguments\"][\"weight\"], float), \"weight should be a float\"\n    assert log[\"arguments\"][\"weight\"] > 0, \"weight should be greater than 0\"\n    \n    # Check if isWithinRegion is a boolean\n    assert isinstance(log[\"arguments\"][\"isWithinRegion\"], bool), \"isWithinRegion should be a boolean\"\n    \n    # Environment integrity check: Ensure env.user_id matches arguments.accountId in related events, if available\n    insert_consign_event = log[\"related_events\"].get(\"consign.service.ConsignServiceImpl.insertConsignRecord\")\n    if insert_consign_event:\n        related_event = insert_consign_event[\"arguments\"][\"consignRequest\"]\n        assert log[\"env\"][\"user_id\"] == related_event[\"accountId\"], \"env.user_id should match related event's accountId\"\n    \n    # Related events check: Ensure accountId in arguments matches one of the accountIds in related events, if available\n    query_by_account_id_event = log[\"related_events\"].get(\"consign.service.ConsignServiceImpl.queryByAccountId\")\n    if query_by_account_id_event:\n        account_ids = [event[\"accountId\"] for event in query_by_account_id_event[\"response\"][\"data\"]]\n        assert log[\"env\"][\"user_id\"] in account_ids, \"env.user_id should match one of the accountIds in related events\"\n\n    # Vulnerability Check: Ensure no SQL injection features in all string fields\n    for key, value in log[\"arguments\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain SQL injection features\"\n    \n    for key, value in log[\"env\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain SQL injection features\"\n    \n    for event_name, event in log[\"related_events\"].items():\n        if event and event.get(\"arguments\"):\n            for key, value in event[\"arguments\"].items():\n                if isinstance(value, str):\n                    assert not SQL_INJECTION_RE.search(value), f\"{key} in {event_name} arguments should not contain SQL injection features\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.getAllFood", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nDATE_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n\ndef check(log: dict) -> bool:\n    arguments = log['arguments']\n    env = log['env']\n    related_events = log['related_events']\n\n    # Format Check\n    assert DATE_RE.match(arguments['date']), \"date should be in YYYY-MM-DD format\"\n    assert isinstance(arguments['tripId'], str) and arguments['tripId'], \"tripId should be a non-empty string\"\n    assert isinstance(arguments['startStation'], str) and arguments['startStation'], \"startStation should be a non-empty string\"\n    assert isinstance(arguments['endStation'], str) and arguments['endStation'], \"endStation should be a non-empty string\"\n\n    # Vulnerability Check\n    for value in arguments.values():\n        assert not SQL_INJECTION_RE.search(value), f\"{value} should not contain SQL injection keywords\"\n\n    # Database integrity Check\n    def check_event_data(event_data):\n        for entry in event_data:\n            assert env['user_id'] == entry['accountId'], \"user_id should match the 'accountId' in the related event\"\n\n    if related_events:\n        for event in related_events.values():\n            if event and 'response' in event and event['response'] and 'data' in event['response']:\n                response_data = event['response']['data']\n                if response_data:\n                    check_event_data(response_data)\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "cancel.service.CancelServiceImpl.cancelOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"loginId\"], str), \"loginId should be a string\"\n    \n    # SQL Injection Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"loginId\"]), \"loginId should not contain any SQL injection features\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"loginId\"] == log[\"env\"][\"user_id\"], \"loginId should match env.user_id\"\n    \n    # Database Integrity Check\n    get_order_response = log[\"related_events\"][\"order.service.OrderServiceImpl.getOrderById\"][\"response\"]\n    if get_order_response[\"status\"] == 1:\n        assert \"data\" in get_order_response, \"data should be present when status is successful\"\n        assert log[\"arguments\"][\"orderId\"] == get_order_response[\"data\"][\"id\"], \"orderId should match the id in getOrderById response\"\n    else:\n        print(\"Order not found in getOrderById response\")\n    \n    # Related Events Check\n    query_orders_event = log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"]\n    assert log[\"arguments\"][\"loginId\"] == query_orders_event[\"arguments\"][\"qi\"][\"loginId\"], \"loginId should match the loginId in queryOrders\"\n    \n    other_query_orders_event = log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"]\n    assert log[\"arguments\"][\"loginId\"] == other_query_orders_event[\"arguments\"][\"qi\"][\"loginId\"], \"loginId should match the loginId in other.queryOrders\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "seat.service.SeatServiceImpl.distributeSeat", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": false, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nDATE_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n\ndef check(log: dict) -> bool:\n    # Unpack fields for easier access\n    seat_request = log[\"arguments\"][\"seatRequest\"]\n    env = log[\"env\"]\n    related_events = log.get(\"related_events\", {})\n\n    # Format Check\n    assert DATE_RE.match(seat_request[\"travelDate\"]), \"travelDate should be in YYYY-MM-DD format\"\n    assert isinstance(seat_request[\"trainNumber\"], str) and seat_request[\"trainNumber\"], \"trainNumber should be a non-empty string\"\n    assert isinstance(seat_request[\"startStation\"], str) and seat_request[\"startStation\"], \"startStation should be a non-empty string\"\n    assert isinstance(seat_request[\"destStation\"], str) and seat_request[\"destStation\"], \"destStation should be a non-empty string\"\n    assert all(isinstance(station, str) and station for station in seat_request[\"stations\"]), \"stations should be a list of non-empty strings\"\n\n    # Vulnerability Check\n    for field in [\"trainNumber\", \"startStation\", \"destStation\"] + seat_request[\"stations\"]:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain SQL injection features\"\n\n    # Range Check\n    assert isinstance(seat_request[\"seatType\"], int), \"seatType should be an integer\"\n    assert isinstance(seat_request[\"totalNum\"], int) and 0 < seat_request[\"totalNum\"] <= 2147483647, \"totalNum should be a positive integer and within a reasonable range\"\n\n    # Internal Consistency Check\n    assert seat_request[\"startStation\"] in seat_request[\"stations\"], \"startStation should be in the list of stations\"\n    assert seat_request[\"destStation\"] in seat_request[\"stations\"], \"destStation should be in the list of stations\"\n\n    # Environment Integrity Check\n    for event in related_events.values():\n        if isinstance(event, dict):\n            event_env = event.get(\"env\", {})\n            if \"user_id\" in event_env:\n                assert env[\"user_id\"] == event_env[\"user_id\"], \"user_id in env should match user_id in related events' env\"\n\n    return True\n", "num_args": 1}}
