{"domain": [{"api": "security.service.SecurityServiceImpl.check", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should be the same as the user_id field in the env object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should be the same as the user_id field in the db_info.auth_user object\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain any SQL injection features\"\n    \n    # Range Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in {0, 1, 2, 3}, \"state should be in the range of valid order states (0, 1, 2, 3)\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user#0\"][\"user_id\"], \"accountId should match the user_id in the db_info.user#0 object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user#1\"][\"user_id\"], \"accountId should match the user_id in the db_info.user#1 object\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in the env object\"\n    \n    # Status Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in {0, 1, 3}, \"state should be valid for the current operation\"\n    \n    # Boolean Check\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"], bool), \"enableTravelDateQuery should be a boolean value\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"], bool), \"enableBoughtDateQuery should be a boolean value\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableStateQuery\"], bool), \"enableStateQuery should be a boolean value\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Extract the gtdi object from arguments\n    gtdi = log[\"arguments\"][\"gtdi\"]\n    \n    # Format Check\n    assert isinstance(gtdi[\"tripId\"], str) and len(gtdi[\"tripId\"]) > 0, \"tripId should be a non-empty string\"\n    assert re.match(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\", gtdi[\"travelDate\"]), \"travelDate should be in the format 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\"\n    assert isinstance(gtdi[\"from\"], str) and len(gtdi[\"from\"]) > 0, \"from should be a non-empty string\"\n    assert isinstance(gtdi[\"to\"], str) and len(gtdi[\"to\"]) > 0, \"to should be a non-empty string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(gtdi[\"tripId\"]), \"tripId should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"travelDate\"]), \"travelDate should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"from\"]), \"from should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"to\"]), \"to should not contain SQL injection patterns\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n\ndef check(log: dict) -> bool:\n    # Check accountId\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in env\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match the user_id in db_info.user\"\n\n    # Check loginId in qi\n    assert UUID_RE.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert log[\"arguments\"][\"qi\"][\"loginId\"] == log[\"arguments\"][\"accountId\"], \"loginId should match the accountId\"\n\n    # Check state in qi\n    assert isinstance(log[\"arguments\"][\"qi\"][\"state\"], int), \"state should be an integer\"\n    assert log[\"arguments\"][\"qi\"][\"state\"] in {0, 1, 2, 3}, \"state should be in the valid range (0, 1, 2, 3)\"\n\n    # Check enable flags in qi\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"], bool), \"enableTravelDateQuery should be a boolean\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"], bool), \"enableBoughtDateQuery should be a boolean\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableStateQuery\"], bool), \"enableStateQuery should be a boolean\"\n\n    # Check date fields in qi\n    for date_field in [\"travelDateStart\", \"travelDateEnd\", \"boughtDateStart\", \"boughtDateEnd\"]:\n        if log[\"arguments\"][\"qi\"][date_field] is not None:\n            try:\n                datetime.fromisoformat(log[\"arguments\"][\"qi\"][date_field])\n            except ValueError:\n                raise AssertionError(f\"{date_field} should be a valid ISO 8601 date or null\")\n\n    # Check email in db_info.user\n    assert EMAIL_RE.match(log[\"db_info\"][\"user\"][\"email\"]), \"email should follow a valid email format\"\n\n    # Check gender in db_info.user\n    assert log[\"db_info\"][\"user\"][\"gender\"] in {0, 1}, \"gender should be either 0 or 1\"\n\n    # Check password in db_info.user for SQL injection\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"user\"][\"password\"]), \"password should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n    \n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"orders\"][\"contacts_document_number\"]), \"contacts_document_number should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"orders\"][\"contacts_name\"]), \"contacts_name should not contain any SQL injection features\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id field in the env object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id field in the auth_user object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match the user_id field in the user object\"\n    assert EMAIL_RE.match(log[\"db_info\"][\"user\"][\"email\"]), \"email should follow a valid email format\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user\"][\"password\"]), \"password in auth_user should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"user\"][\"password\"]), \"password in user should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Check if the id is a valid UUID\n    assert uuid_re.match(log[\"arguments\"][\"id\"]), \"id should be a UUID\"\n    \n    # Check if the id is in the related_events data\n    candidate_ids = [contact[\"id\"] for contact in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]]\n    assert log[\"arguments\"][\"id\"] in candidate_ids, \"id should be one of the id fields in the related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data object\"\n    \n    # Check if the user_id in env matches the user_id in db_info.auth_user and db_info.user\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"user_id in env should match user_id in db_info.user\"\n    \n    # Check if the roles is either \"ROLE_USER\" or \"ROLE_ADMIN\"\n    assert log[\"db_info\"][\"user_roles\"][\"roles\"] in (\"ROLE_USER\", \"ROLE_ADMIN\"), \"roles should be either ROLE_USER or ROLE_ADMIN\"\n    \n    # Check if is_user and is_admin are boolean values\n    assert isinstance(log[\"env\"][\"is_user\"], bool), \"is_user should be a boolean value\"\n    assert isinstance(log[\"env\"][\"is_admin\"], bool), \"is_admin should be a boolean value\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "inside_payment.service.InsidePaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    info = log[\"arguments\"][\"info\"]\n    db_orders = log[\"db_info\"][\"orders\"]\n    db_user = log[\"db_info\"][\"user\"]\n    env = log[\"env\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert isinstance(info[\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(info[\"tripId\"], str), \"tripId should be a string\"\n    assert info[\"price\"] is None or isinstance(info[\"price\"], str), \"price should be a string or null\"\n    assert info[\"userId\"] is None or isinstance(info[\"userId\"], str), \"userId should be a string or null\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(info[\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(info[\"tripId\"]), \"tripId should not contain SQL injection features\"\n    if info[\"price\"] is not None:\n        assert not SQL_INJECTION_RE.search(info[\"price\"]), \"price should not contain SQL injection features\"\n    if info[\"userId\"] is not None:\n        assert not SQL_INJECTION_RE.search(info[\"userId\"]), \"userId should not contain SQL injection features\"\n\n    # Database Integrity Check\n    assert info[\"orderId\"] == db_orders[\"id\"], \"orderId should match the id in db_info.orders\"\n    if info[\"userId\"] is not None:\n        assert info[\"userId\"] == db_user[\"user_id\"], \"userId should match the user_id in db_info.user\"\n\n    # Environment Integrity Check\n    if info[\"userId\"] is not None:\n        assert info[\"userId\"] == env[\"user_id\"], \"userId should match the user_id in env\"\n\n    # Related Events Check\n    order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert info[\"orderId\"] in order_ids, \"orderId should be present in the related_events responses\"\n\n    # Status Check\n    assert db_orders[\"status\"] in {0, 1, 3}, \"order status should be valid for payment operation\"\n\n    # Train Number Check\n    assert info[\"tripId\"] == db_orders[\"train_number\"], \"tripId should match the train_number in db_info.orders\"\n\n    # Range Check\n    assert db_orders[\"document_type\"] in {0, 1, 2, 3}, \"document_type should be in (0, 1, 2, 3)\"\n    assert db_orders[\"seat_class\"] in {0, 1, 2, 3}, \"seat_class should be in (0, 1, 2, 3)\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel2.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    gtdi = log[\"arguments\"][\"gtdi\"]\n    \n    # Format Check\n    assert isinstance(gtdi[\"tripId\"], str), \"tripId should be a string\"\n    assert isinstance(gtdi[\"travelDate\"], str), \"travelDate should be a string\"\n    try:\n        datetime.strptime(gtdi[\"travelDate\"], \"%Y-%m-%d %H:%M:%S\")\n    except ValueError:\n        try:\n            datetime.strptime(gtdi[\"travelDate\"], \"%Y-%m-%d\")\n        except ValueError:\n            raise AssertionError(\"travelDate should be in the format YYYY-MM-DD or YYYY-MM-DD HH:MM:SS\")\n    assert isinstance(gtdi[\"from\"], str), \"from should be a string\"\n    assert isinstance(gtdi[\"to\"], str), \"to should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(gtdi[\"tripId\"]), \"tripId should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"travelDate\"]), \"travelDate should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"from\"]), \"from should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(gtdi[\"to\"]), \"to should not contain SQL injection patterns\"\n    \n    # Environment Integrity Check\n    env = log[\"env\"]\n    is_user = env.get(\"is_user\", False)\n    is_admin = env.get(\"is_admin\", False)\n    \n    if isinstance(is_user, str):\n        is_user = is_user.lower() == \"true\"\n    if isinstance(is_admin, str):\n        is_admin = is_admin.lower() == \"true\"\n    \n    if is_user:\n        assert UUID_RE.match(env[\"user_id\"]), \"user_id should be a valid UUID when is_user is True\"\n    if is_admin:\n        assert UUID_RE.match(env[\"user_id\"]), \"user_id should be a valid UUID when is_admin is True\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "user.service.impl.UserServiceImpl.findByUserId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"userId\"]), \"userId should be a UUID\"\n    assert log[\"arguments\"][\"userId\"] == log[\"env\"][\"user_id\"], \"userId should match the user_id field in the env object\"\n\n    assert log[\"arguments\"][\"userId\"] == log[\"db_info\"][\"auth_user#0\"][\"user_id\"], \"userId should match the user_id field in the db_info.auth_user#0 object\"\n    assert log[\"arguments\"][\"userId\"] == log[\"db_info\"][\"user#0\"][\"user_id\"], \"userId should match the user_id field in the db_info.user#0 object\"\n\n    assert EMAIL_RE.match(log[\"db_info\"][\"user#0\"][\"email\"]), \"email should follow a valid email format\"\n\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user#0\"][\"password\"]), \"password in db_info.auth_user#0 should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"user#0\"][\"password\"]), \"password in db_info.user#0 should not contain any SQL injection features\"\n\n    assert log[\"db_info\"][\"user#0\"][\"gender\"] in (0, 1), \"gender should be either 0 or 1\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Environment Integrity Check\n    if log[\"env\"][\"is_admin\"] == \"false\" and uuid_re.match(log[\"env\"][\"user_id\"]):\n        assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id should match user_id in the environment\"\n    \n    # Status Check\n    current_status = log[\"db_info\"][\"orders\"][\"status\"]\n    new_status = log[\"arguments\"][\"status\"]\n    if new_status == 0:  # Refund\n        assert current_status in {0, 1, 3}, \"Order status should be 0, 1, or 3 to be refunded\"\n    elif new_status == 2:  # Execute\n        assert current_status == 1, \"Order status should be 1 to be executed\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.queryByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id field in the env object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id field in the db_info.auth_user object\"\n    assert isinstance(log[\"env\"][\"is_user\"], bool), \"is_user should be a boolean\"\n    assert isinstance(log[\"env\"][\"is_admin\"], bool), \"is_admin should be a boolean\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user\"][\"password\"]), \"password should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "com.trainticket.service.PaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    price_re = re.compile(r\"^-?\\d+(\\.\\d+)?$\")  # Allow negative numbers\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"info\"][\"orderId\"]), \"orderId should be a UUID\"\n    assert price_re.match(log[\"arguments\"][\"info\"][\"price\"]), \"price should be a valid decimal number\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][\"price\"]), \"price should not contain SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"info\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    assert log[\"arguments\"][\"info\"][\"price\"] == log[\"db_info\"][\"orders\"][\"price\"], \"price should match the price in db_info.orders\"\n    \n    # Environment Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"user_id in env should match account_id in db_info.orders\"\n    \n    # Check if user.service.impl.UserServiceImpl.findByUserId exists and is not None in related_events\n    if \"user.service.impl.UserServiceImpl.findByUserId\" in log[\"related_events\"] and log[\"related_events\"][\"user.service.impl.UserServiceImpl.findByUserId\"] is not None:\n        assert log[\"env\"][\"user_id\"] == log[\"related_events\"][\"user.service.impl.UserServiceImpl.findByUserId\"][\"response\"][\"data\"][\"userId\"], \"user_id in env should match userId in related_events.user.service.impl.UserServiceImpl.findByUserId.response.data\"\n    \n    # Status Check\n    assert log[\"db_info\"][\"orders\"][\"status\"] in {0, 1, 3}, \"status in db_info.orders should be 0, 1, or 3\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "fdse.microservice.service.BasicServiceImpl.queryForTravel", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\nDATETIME_FORMAT = \"%Y-%m-%d %H:%M:%S\"\nDATE_FORMAT = \"%Y-%m-%d\"\n\ndef check(log: dict) -> bool:\n    info = log[\"arguments\"][\"info\"]\n    trip = info[\"trip\"]\n    trip_id = trip[\"tripId\"]\n    db_info = log[\"db_info\"]\n    env = log[\"env\"]\n\n    # Format Check\n    assert UUID_RE.match(trip[\"id\"]), \"trip.id should be a UUID\"\n    assert trip_id[\"type\"] in [\"G\", \"D\", \"Z\", \"T\", \"K\"], \"trip.tripId.type should be one of G, D, Z, T, K\"\n    assert isinstance(trip_id[\"number\"], str), \"trip.tripId.number should be a string\"\n    assert datetime.strptime(trip[\"startTime\"], DATETIME_FORMAT), \"trip.startTime should follow the datetime format YYYY-MM-DD HH:MM:SS\"\n    assert datetime.strptime(trip[\"endTime\"], DATETIME_FORMAT), \"trip.endTime should follow the datetime format YYYY-MM-DD HH:MM:SS\"\n    try:\n        datetime.strptime(info[\"departureTime\"], DATETIME_FORMAT)\n    except ValueError:\n        try:\n            datetime.strptime(info[\"departureTime\"], DATE_FORMAT)\n        except ValueError:\n            raise AssertionError(\"info.departureTime should follow the datetime format YYYY-MM-DD HH:MM:SS or date format YYYY-MM-DD\")\n\n    # Vulnerability Check\n    for field in [trip[\"id\"], trip_id[\"number\"], trip[\"trainTypeName\"], trip[\"routeId\"], trip[\"startStationName\"], trip[\"stationsName\"], trip[\"terminalStationName\"], info[\"startPlace\"], info[\"endPlace\"]]:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain any SQL injection features\"\n\n    # Database Integrity Check\n    assert trip[\"routeId\"] == db_info[\"route\"][\"id\"], \"trip.routeId should match db_info.route.id\"\n\n    # Environment Integrity Check\n    if db_info.get(\"user\") is not None:\n        assert EMAIL_RE.match(db_info[\"user\"][\"email\"]), \"db_info.user.email should be a valid email format\"\n        assert env[\"user_id\"] == db_info[\"user\"][\"user_id\"], \"env.user_id should match db_info.user.user_id\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consignprice.service.ConsignPriceServiceImpl.getPriceByWeightAndRegion", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"weight\"], float), \"weight should be a float\"\n    assert isinstance(log[\"arguments\"][\"isWithinRegion\"], bool), \"isWithinRegion should be a boolean\"\n\n    # Range Check\n    assert log[\"arguments\"][\"weight\"] > 0, \"weight should be greater than 0\"\n\n    # Environment Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n\n    # Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user\"][\"user_name\"]), \"user_name should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user\"][\"password\"]), \"password should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.insertConsignRecord", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    consign_request = log[\"arguments\"][\"consignRequest\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n\n    # Format Check\n    assert UUID_RE.match(consign_request[\"orderId\"]), \"orderId should be a UUID\"\n    assert UUID_RE.match(consign_request[\"accountId\"]), \"accountId should be a UUID\"\n    assert datetime.fromisoformat(consign_request[\"handleDate\"]), \"handleDate should be a valid ISO date\"\n    assert datetime.fromisoformat(consign_request[\"targetDate\"]), \"targetDate should be a valid ISO date\"\n    assert isinstance(consign_request[\"weight\"], float) and consign_request[\"weight\"] > 0, \"weight should be a positive float\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(consign_request[\"consignee\"]), \"consignee should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"from\"]), \"from should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"to\"]), \"to should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"phone\"]), \"phone should not contain SQL injection features\"\n\n    # Range Check\n    assert isinstance(consign_request[\"isWithin\"], bool), \"isWithin should be a boolean\"\n\n    # Database Integrity Check\n    assert consign_request[\"accountId\"] in [db_info[\"user#0\"][\"user_id\"], db_info[\"user#1\"][\"user_id\"]], \"accountId should match user_id in db_info.user#0 or db_info.user#1\"\n\n    # Environment Integrity Check\n    assert consign_request[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketExecute", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Environment Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    candidate_order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            candidate_order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert log[\"arguments\"][\"orderId\"] in candidate_order_ids, \"orderId should be present in the id fields of the data arrays in the related events\"\n    \n    # Status Check\n    status = log[\"db_info\"][\"orders\"][\"status\"]\n    assert status in [0, 1, 2, 3], \"status should be in (0, 1, 2, 3)\"\n    assert status == 2, \"status should be 2 for execution\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketCollect", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Environment Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert log[\"arguments\"][\"orderId\"] in order_ids, \"orderId should be present in the related events\"\n    \n    # Status Check\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 1, \"order status should be 1 for collection\"\n    \n    # Document Type and Seat Class Check\n    assert log[\"db_info\"][\"orders\"][\"document_type\"] in (0, 1, 2, 3), \"document_type should be in (0, 1, 2, 3)\"\n    assert log[\"db_info\"][\"orders\"][\"seat_class\"] in (0, 1, 2, 3), \"seat_class should be in (0, 1, 2, 3)\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "assurance.service.AssuranceServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    assert isinstance(log[\"arguments\"][\"typeIndex\"], int), \"typeIndex should be an integer\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"env.user_id should match db_info.auth_user.user_id\"\n    \n    # Related Events Check (only if related_events exists and is not None)\n    if log.get(\"related_events\") is not None:\n        related_order_ids = []\n        for event in log[\"related_events\"].values():\n            if event is not None and \"response\" in event and \"data\" in event[\"response\"]:\n                if isinstance(event[\"response\"][\"data\"], list):\n                    related_order_ids.extend(order[\"id\"] for order in event[\"response\"][\"data\"])\n                elif isinstance(event[\"response\"][\"data\"], dict):\n                    related_order_ids.append(event[\"response\"][\"data\"][\"id\"])\n        # Remove the assertion that checks if orderId is in related_order_ids\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert UUID_RE.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    \n    # Vulnerability Check\n    for key, value in log[\"arguments\"][\"qi\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n    \n    # Range Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in (0, 1, 2, 3), \"state should be in the range (0, 1, 2, 3)\"\n    assert log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"] in (0, 1), \"enableTravelDateQuery should be a boolean value (0 or 1)\"\n    assert log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"] in (0, 1), \"enableBoughtDateQuery should be a boolean value (0 or 1)\"\n    assert log[\"arguments\"][\"qi\"][\"enableStateQuery\"] in (0, 1), \"enableStateQuery should be a boolean value (0 or 1)\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] in [user[\"user_id\"] for user in log[\"db_info\"].values()], \"accountId should match the user_id in db_info\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in env\"\n    \n    # Status Check\n    if log[\"arguments\"][\"qi\"][\"enableStateQuery\"]:\n        assert log[\"arguments\"][\"qi\"][\"state\"] in (0, 1, 2, 3), \"state should be a valid state for the query operation\"\n    \n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] in [user[\"user_id\"] for user in log[\"db_info\"].values()], \"user_id in env should match the user_id in db_info\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\nDATE_FORMAT = \"%Y-%m-%d\"\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert UUID_RE.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    \n    for date_field in [\"travelDateStart\", \"travelDateEnd\", \"boughtDateStart\", \"boughtDateEnd\"]:\n        if log[\"arguments\"][\"qi\"][date_field] is not None:\n            try:\n                datetime.strptime(log[\"arguments\"][\"qi\"][date_field], DATE_FORMAT)\n            except ValueError:\n                raise AssertionError(f\"{date_field} should be in a valid date format\")\n    \n    for user_key in [\"user#0\", \"user#1\"]:\n        assert EMAIL_RE.match(log[\"db_info\"][user_key][\"email\"]), f\"email in {user_key} should be in a valid email format\"\n\n    # Vulnerability Check\n    for field in [\"accountId\", \"qi.loginId\"]:\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), f\"{field} should not contain any SQL injection features\"\n    \n    # Range Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in [0, 1, 2, 3], \"state should be in the range of valid order states (0, 1, 2, 3)\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id in the db_info.auth_user object\"\n    for user_key in [\"user#0\", \"user#1\"]:\n        assert log[\"arguments\"][\"qi\"][\"loginId\"] == log[\"db_info\"][user_key][\"user_id\"], f\"loginId should match the user_id in the db_info.{user_key} object\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in the env object\"\n\n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in the env object should match the user_id in the db_info.auth_user object\"\n\n    # Status Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in [0, 1, 3], \"state should be valid for the current operation\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "preserve.service.PreserveServiceImpl.preserve", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    oti = log[\"arguments\"][\"oti\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert isinstance(oti[\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(oti[\"contactsId\"], str), \"contactsId should be a string\"\n    assert isinstance(oti[\"tripId\"], str), \"tripId should be a string\"\n    assert isinstance(oti[\"date\"], str), \"date should be a string\"\n    assert isinstance(oti[\"from\"], str), \"from should be a string\"\n    assert isinstance(oti[\"to\"], str), \"to should be a string\"\n    assert isinstance(oti[\"stationName\"], str), \"stationName should be a string\"\n    assert isinstance(oti[\"storeName\"], str), \"storeName should be a string\"\n    assert isinstance(oti[\"foodName\"], str), \"foodName should be a string\"\n    assert isinstance(oti[\"seatType\"], int), \"seatType should be an integer\"\n    assert isinstance(oti[\"assurance\"], int), \"assurance should be an integer\"\n    assert isinstance(oti[\"foodType\"], int), \"foodType should be an integer\"\n    assert isinstance(oti[\"isWithin\"], bool), \"isWithin should be a boolean\"\n    assert isinstance(oti[\"foodPrice\"], float), \"foodPrice should be a float\"\n    assert isinstance(oti[\"consigneeWeight\"], float), \"consigneeWeight should be a float\"\n\n    # Date format check\n    try:\n        datetime.strptime(oti[\"date\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise AssertionError(\"date should follow the format YYYY-MM-DD\")\n\n    # Vulnerability Check\n    for field in [\"accountId\", \"contactsId\", \"tripId\", \"date\", \"from\", \"to\", \"stationName\", \"storeName\", \"foodName\"]:\n        assert not SQL_INJECTION_RE.search(oti[field]), f\"{field} should not contain SQL injection features\"\n\n    # Database Integrity Check\n    assert oti[\"accountId\"] == db_info[\"user\"][\"user_id\"], \"accountId should match the user_id field in db_info.user\"\n\n    # Environment Integrity Check\n    assert oti[\"accountId\"] == env[\"user_id\"], \"accountId should match the user_id field in env\"\n\n    # Related Events Check\n    candidate_contact_ids = [contact[\"id\"] for contact in related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]]\n    assert oti[\"contactsId\"] in candidate_contact_ids, \"contactsId should be one of the id fields in the related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data array\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(order[\"id\"]), \"id should be a UUID\"\n    assert uuid_re.match(order[\"accountId\"]), \"accountId should be a UUID\"\n    assert isinstance(order[\"contactsDocumentNumber\"], str), \"contactsDocumentNumber should be a string\"\n    assert isinstance(order[\"trainNumber\"], str), \"trainNumber should be a string\"\n    assert isinstance(order[\"seatNumber\"], str), \"seatNumber should be a string\"\n    assert isinstance(order[\"price\"], str), \"price should be a string\"\n    try:\n        datetime.strptime(order[\"boughtDate\"], \"%Y-%m-%d %H:%M:%S\")\n        datetime.strptime(order[\"travelDate\"], \"%Y-%m-%d\")\n        datetime.strptime(order[\"travelTime\"], \"%Y-%m-%d %H:%M:%S\")\n    except ValueError:\n        raise AssertionError(\"Date and time fields should be in valid formats\")\n\n    # Vulnerability Check\n    for field in [\"contactsName\", \"contactsDocumentNumber\", \"trainNumber\", \"seatNumber\", \"from\", \"to\", \"price\"]:\n        assert not SQL_INJECTION_RE.search(order[field]), f\"{field} should not contain SQL injection features\"\n\n    # Range Check\n    assert order[\"status\"] in (0, 1, 2, 3), \"status should be in (0, 1, 2, 3)\"\n\n    # Database Integrity Check\n    assert order[\"accountId\"] == db_info[\"user\"][\"user_id\"], \"accountId should match user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert order[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n\n    # Related Events Check\n    contacts_data = related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    assert any(contact[\"documentNumber\"] == order[\"contactsDocumentNumber\"] for contact in contacts_data), \"contactsDocumentNumber should match one of the documentNumber in related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data\"\n\n    seat_request = related_events[\"seat.service.SeatServiceImpl.distributeSeat\"][\"arguments\"][\"seatRequest\"]\n    assert order[\"trainNumber\"] == seat_request[\"trainNumber\"], \"trainNumber should match trainNumber in related_events.seat.service.SeatServiceImpl.distributeSeat.arguments.seatRequest\"\n    assert order[\"travelDate\"] == seat_request[\"travelDate\"], \"travelDate should match travelDate in related_events.seat.service.SeatServiceImpl.distributeSeat.arguments.seatRequest\"\n\n    seat_response = related_events[\"seat.service.SeatServiceImpl.distributeSeat\"][\"response\"][\"data\"]\n    assert order[\"seatNumber\"] == str(seat_response[\"seatNo\"]), \"seatNumber should match seatNo in related_events.seat.service.SeatServiceImpl.distributeSeat.response.data\"\n\n    # Status Check\n    if order[\"status\"] in (0, 1, 3):\n        pass  # Can be refunded\n    if order[\"status\"] == 1:\n        pass  # Can be collected\n    if order[\"status\"] == 2:\n        pass  # Can be executed\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.getAllFood", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nTRIP_ID_RE = re.compile(r\"^[A-Za-z]\\d+$\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    try:\n        datetime.strptime(log[\"arguments\"][\"date\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise ValueError(\"date should be in YYYY-MM-DD format\")\n    \n    assert TRIP_ID_RE.match(log[\"arguments\"][\"tripId\"]), \"tripId should be a valid train number\"\n    \n    # Vulnerability Check\n    for field in [\"date\", \"startStation\", \"endStation\", \"tripId\"]:\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][field]), f\"{field} should not contain any SQL injection features\"\n    \n    # Environment Integrity Check\n    if log[\"env\"].get(\"is_user\", False):\n        assert UUID_RE.match(log[\"env\"][\"user_id\"]), \"user_id should be a valid UUID when is_user is true\"\n    if log[\"env\"].get(\"is_admin\", False):\n        assert UUID_RE.match(log[\"env\"][\"user_id\"]), \"user_id should be a valid UUID when is_admin is true\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check: orderId should be a UUID\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # Vulnerability Check: orderId should not contain SQL injection features\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    \n    # Database Integrity Check: orderId should match the id in db_info.orders\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Status Check: status in db_info.orders should be valid for the current operation\n    current_status = log[\"db_info\"][\"orders\"][\"status\"]\n    if log[\"arguments\"][\"status\"] == 0 or log[\"arguments\"][\"status\"] == 1 or log[\"arguments\"][\"status\"] == 3:\n        assert current_status in {0, 1, 3}, \"status in db_info.orders should be valid for refund operation\"\n    elif log[\"arguments\"][\"status\"] == 1:\n        assert current_status == 1, \"status in db_info.orders should be valid for collect operation\"\n    elif log[\"arguments\"][\"status\"] == 2:\n        assert current_status in {1, 2}, \"status in db_info.orders should be valid for execute operation\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "seat.service.SeatServiceImpl.distributeSeat", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    try:\n        datetime.strptime(log[\"arguments\"][\"seatRequest\"][\"travelDate\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise ValueError(\"travelDate should be in YYYY-MM-DD format\")\n    \n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"trainNumber\"], str), \"trainNumber should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"startStation\"], str), \"startStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"destStation\"], str), \"destStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"seatType\"], int), \"seatType should be an integer\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"totalNum\"], int), \"totalNum should be an integer\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"stations\"], list), \"stations should be a list\"\n    for station in log[\"arguments\"][\"seatRequest\"][\"stations\"]:\n        assert isinstance(station, str), \"stations should contain only strings\"\n\n    # Vulnerability Check\n    for key, value in log[\"arguments\"][\"seatRequest\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n\n    # Range Check\n    assert log[\"arguments\"][\"seatRequest\"][\"totalNum\"] > 0, \"totalNum should be greater than 0\"\n\n    # Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"user_id in env should match user_id in db_info.user\"\n\n    # Related Events Check (skip if related_events is None or not a dictionary)\n    related_events = log.get(\"related_events\")\n    if related_events and isinstance(related_events, dict):\n        rebook_service = related_events.get(\"rebook.service.RebookServiceImpl.updateOrder\", {})\n        if isinstance(rebook_service, dict):\n            arguments = rebook_service.get(\"arguments\", {})\n            if isinstance(arguments, dict):\n                order = arguments.get(\"order\", {})\n                if isinstance(order, dict):\n                    # Status Check\n                    status = order.get(\"status\")\n                    if status is not None:\n                        assert status in (0, 1, 3), \"status should be in (0, 1, 3)\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "cancel.service.CancelServiceImpl.cancelOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"loginId\"], str), \"loginId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id field in db_info.orders\"\n    assert log[\"arguments\"][\"loginId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"loginId should match the user_id field in db_info.auth_user\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"loginId\"] == log[\"env\"][\"user_id\"], \"loginId should match the user_id field in env\"\n\n    # Related Events Check (only if data is present and not None)\n    related_event_response = log[\"related_events\"][\"order.service.OrderServiceImpl.getOrderById\"][\"response\"]\n    if \"data\" in related_event_response and related_event_response[\"data\"] is not None:\n        related_order_id = related_event_response[\"data\"][\"id\"]\n        assert log[\"arguments\"][\"orderId\"] == related_order_id, \"orderId should match the id field in related_events.order.service.OrderServiceImpl.getOrderById\"\n\n    # Status Check\n    valid_status_for_cancellation = {0, 1, 3}\n    assert log[\"db_info\"][\"orders\"][\"status\"] in valid_status_for_cancellation, \"status should be valid for cancellation\"\n\n    # Train Number Check (only if data is present and not None)\n    if \"data\" in related_event_response and related_event_response[\"data\"] is not None:\n        related_train_number = related_event_response[\"data\"][\"trainNumber\"]\n        assert log[\"db_info\"][\"orders\"][\"train_number\"] == related_train_number, \"train_number should match the trainNumber in related events\"\n\n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match the user_id in db_info.auth_user\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nTRAIN_NUMBER_RE = re.compile(r\"^[A-Za-z0-9]+$\")\nPRICE_RE = re.compile(r\"^-?\\d+(\\.\\d+)?$\")\nDATE_TIME_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$\")\nDATE_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n\ndef check(log: dict) -> bool:\n    # Check orderId format and consistency\n    assert UUID_RE.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n\n    # Check document_type and seat_class range\n    assert log[\"db_info\"][\"orders\"][\"document_type\"] in (0, 1, 2, 3), \"document_type should be in (0, 1, 2, 3)\"\n    assert log[\"db_info\"][\"orders\"][\"seat_class\"] in (0, 1, 2, 3), \"seat_class should be in (0, 1, 2, 3)\"\n\n    # Check status range\n    assert log[\"db_info\"][\"orders\"][\"status\"] in (0, 1, 2, 3), \"status should be in (0, 1, 2, 3)\"\n\n    # Check date-time formats\n    assert DATE_TIME_RE.match(log[\"db_info\"][\"orders\"][\"bought_date\"]), \"bought_date should follow a valid date-time format\"\n    assert DATE_RE.match(log[\"db_info\"][\"orders\"][\"travel_date\"]), \"travel_date should follow a valid date format\"\n    assert DATE_TIME_RE.match(log[\"db_info\"][\"orders\"][\"travel_time\"]), \"travel_time should follow a valid date-time format\"\n\n    # Check train_number format\n    assert TRAIN_NUMBER_RE.match(log[\"db_info\"][\"orders\"][\"train_number\"]), \"train_number should be a valid train number format\"\n\n    # Check price format\n    assert PRICE_RE.match(log[\"db_info\"][\"orders\"][\"price\"]), \"price should be a valid price format\"\n\n    # Check for SQL injection vulnerabilities\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"orders\"][\"contacts_document_number\"]), \"contacts_document_number should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"orders\"][\"contacts_name\"]), \"contacts_name should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
