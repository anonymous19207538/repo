{"domain": [{"api": "security.service.SecurityServiceImpl.check", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    account_id = log[\"arguments\"][\"accountId\"]\n    \n    # Format Check: accountId should be a UUID\n    assert uuid_re.match(account_id), \"accountId should be a UUID\"\n    \n    # Environment integrity check: accountId should match user_id in env\n    assert account_id == log[\"env\"][\"user_id\"], \"accountId should match user_id in env\"\n    \n    # Database integrity check: accountId should match user_id in db_info.auth_user\n    assert account_id == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match user_id in db_info.auth_user\"\n    \n    # Related events check: accountId should match accountId in related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data\n    for contact in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]:\n        assert account_id == contact[\"accountId\"], \"accountId should match accountId in related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data\"\n    \n    # Vulnerability Check: accountId should not contain SQL injection features\n    assert not SQL_INJECTION_RE.search(account_id), \"accountId should not contain any SQL injection features\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"loginId\"], str), \"loginId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should not contain any SQL injection features\"\n\n    # Range Check for state\n    assert log[\"arguments\"][\"qi\"][\"state\"] in {0, 1, 2, 3}, \"state should be in {0, 1, 2, 3}\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match the user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in env\"\n\n    # Related Events Check\n    related_events = log[\"related_events\"]\n    for event in related_events.values():\n        if event is not None and event.get(\"response\") is not None and isinstance(event[\"response\"].get(\"data\"), list):\n            for order in event[\"response\"][\"data\"]:\n                if order[\"accountId\"] == log[\"arguments\"][\"accountId\"]:\n                    break\n            else:\n                raise AssertionError(f\"accountId {log['arguments']['accountId']} not found in related_events\")\n\n    # Status Check\n    state = log[\"arguments\"][\"qi\"][\"state\"]\n    if state not in {0, 1, 3}:\n        raise AssertionError(\"state should be in {0, 1, 3} for refund operation\")\n\n    # Range Check for documentType and seatClass\n    if \"documentType\" in log[\"arguments\"][\"qi\"]:\n        assert log[\"arguments\"][\"qi\"][\"documentType\"] in {0, 1, 2}, \"documentType should be in {0, 1, 2}\"\n    if \"seatClass\" in log[\"arguments\"][\"qi\"]:\n        assert log[\"arguments\"][\"qi\"][\"seatClass\"] in {0, 1}, \"seatClass should be in {0, 1}\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"loginId\"], str), \"loginId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # Range Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] in {0, 1, 2, 3}, \"state should be in (0, 1, 2, 3)\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in the env field\"\n\n    # Database Integrity Check\n    user_ids = [user[\"user_id\"] for user in log[\"db_info\"].values()]\n    assert log[\"arguments\"][\"accountId\"] in user_ids, \"accountId should match the user_id in the db_info field\"\n\n    # Related Events Check\n    if \"related_events\" in log and log[\"related_events\"] is not None:\n        related_events = log[\"related_events\"]\n        for event in related_events.values():\n            if event is not None and \"arguments\" in event and \"accountId\" in event[\"arguments\"]:\n                assert log[\"arguments\"][\"accountId\"] == event[\"arguments\"][\"accountId\"], \"accountId should match the accountId in the related_events field\"\n\n    # Status Check\n    state = log[\"arguments\"][\"qi\"][\"state\"]\n    assert state in {0, 1, 3}, \"state should be in (0, 1, 3) for the current operation\"\n\n    # Boolean Check\n    assert log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"] in {0, 1}, \"enableTravelDateQuery should be 0 or 1\"\n    assert log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"] in {0, 1}, \"enableBoughtDateQuery should be 0 or 1\"\n    assert log[\"arguments\"][\"qi\"][\"enableStateQuery\"] in {0, 1}, \"enableStateQuery should be 0 or 1\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "inside_payment.service.InsidePaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    info = log[\"arguments\"][\"info\"]\n    db_orders = log[\"db_info\"][\"orders\"]\n    db_user = log[\"db_info\"][\"user\"]\n    env = log[\"env\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert isinstance(info[\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(info[\"tripId\"], str), \"tripId should be a string\"\n    assert info[\"price\"] is None or isinstance(info[\"price\"], str), \"price should be a string or null\"\n    assert info[\"userId\"] is None or isinstance(info[\"userId\"], str), \"userId should be a string or null\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(info[\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(info[\"tripId\"]), \"tripId should not contain SQL injection features\"\n    if info[\"price\"] is not None:\n        assert not SQL_INJECTION_RE.search(info[\"price\"]), \"price should not contain SQL injection features\"\n    if info[\"userId\"] is not None:\n        assert not SQL_INJECTION_RE.search(info[\"userId\"]), \"userId should not contain SQL injection features\"\n\n    # Database Integrity Check\n    assert info[\"orderId\"] == db_orders[\"id\"], \"orderId should match the id in db_info.orders\"\n    if info[\"userId\"] is not None:\n        assert info[\"userId\"] == db_user[\"user_id\"], \"userId should match the user_id in db_info.user\"\n\n    # Environment Integrity Check\n    if info[\"userId\"] is not None:\n        assert info[\"userId\"] == env[\"user_id\"], \"userId should match the user_id in env\"\n\n    # Related Events Check\n    order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert info[\"orderId\"] in order_ids, \"orderId should be present in the related_events responses\"\n\n    # Status Check\n    assert db_orders[\"status\"] in {0, 1, 3}, \"order status should be valid for payment operation\"\n\n    # Train Number Check\n    assert info[\"tripId\"] == db_orders[\"train_number\"], \"tripId should match the train_number in db_info.orders\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id field in the db_info.orders object\"\n    \n    # Status Check\n    status = log[\"db_info\"][\"orders\"][\"status\"]\n    assert status in (0, 1, 2, 3), \"status should be in (0, 1, 2, 3)\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    # Format Check: orderId should be a UUID\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n\n    # Database Integrity Check: orderId should match id in db_info.orders\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match id in db_info.orders\"\n\n    # Status Check: status in db_info.orders should be valid for the current operation\n    current_status = log[\"db_info\"][\"orders\"][\"status\"]\n    new_status = log[\"arguments\"][\"status\"]\n    if new_status == 0 or new_status == 1 or new_status == 3:\n        assert current_status in {0, 1, 3}, \"status in db_info.orders should be valid for refund operation\"\n    elif new_status == 1:\n        assert current_status == 1, \"status in db_info.orders should be valid for collect operation\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nEMAIL_RE = re.compile(r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id field in the env object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id field in the auth_user object\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match the user_id field in the user object\"\n    assert EMAIL_RE.match(log[\"db_info\"][\"user\"][\"email\"]), \"email should follow a valid email format\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"auth_user\"][\"password\"]), \"password in auth_user should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"db_info\"][\"user\"][\"password\"]), \"password in user should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Check if the id is a valid UUID\n    assert uuid_re.match(log[\"arguments\"][\"id\"]), \"id should be a UUID\"\n    \n    # Check if the id is in the related_events data\n    candidate_ids = [contact[\"id\"] for contact in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]]\n    assert log[\"arguments\"][\"id\"] in candidate_ids, \"id should be one of the id fields in the related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data object\"\n    \n    # Check if the user_id in env matches the user_id in db_info.auth_user and db_info.user\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"user_id in env should match user_id in db_info.user\"\n    \n    # Check if the roles is either \"ROLE_USER\" or \"ROLE_ADMIN\"\n    assert log[\"db_info\"][\"user_roles\"][\"roles\"] in (\"ROLE_USER\", \"ROLE_ADMIN\"), \"roles should be either ROLE_USER or ROLE_ADMIN\"\n    \n    # Check if is_user and is_admin are boolean values\n    assert isinstance(log[\"env\"][\"is_user\"], bool), \"is_user should be a boolean value\"\n    assert isinstance(log[\"env\"][\"is_admin\"], bool), \"is_admin should be a boolean value\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "fdse.microservice.service.BasicServiceImpl.queryForTravel", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nVALID_TYPES = {\"G\", \"D\", \"Z\", \"T\", \"K\"}\n\ndef check(log: dict) -> bool:\n    # Format Check\n    def is_valid_time(time_str):\n        try:\n            # Try parsing with full datetime format\n            datetime.strptime(time_str, \"%Y-%m-%d %H:%M:%S\")\n            return True\n        except ValueError:\n            try:\n                # Try parsing with date-only format\n                datetime.strptime(time_str, \"%Y-%m-%d\")\n                return True\n            except ValueError:\n                return False\n\n    assert is_valid_time(log[\"arguments\"][\"info\"][\"departureTime\"]), \"departureTime should be in valid time format\"\n    assert is_valid_time(log[\"arguments\"][\"info\"][\"trip\"][\"endTime\"]), \"endTime should be in valid time format\"\n    assert is_valid_time(log[\"arguments\"][\"info\"][\"trip\"][\"startTime\"]), \"startTime should be in valid time format\"\n    assert log[\"arguments\"][\"info\"][\"trip\"][\"tripId\"][\"type\"] in VALID_TYPES, \"tripId.type should be one of G, D, Z, T, K\"\n\n    # Vulnerability Check\n    for key, value in log[\"arguments\"][\"info\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n\n    # Range Check (only if 'user' exists in db_info and is not None)\n    if \"user\" in log[\"db_info\"] and log[\"db_info\"][\"user\"] is not None:\n        assert log[\"db_info\"][\"user\"][\"document_type\"] in {0, 1, 2, 3}, \"document_type should be in (0, 1, 2, 3)\"\n        assert log[\"db_info\"][\"user\"][\"gender\"] in {0, 1}, \"gender should be in (0, 1)\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"info\"][\"trip\"][\"routeId\"] == log[\"db_info\"][\"route\"][\"id\"], \"routeId should match the id field in db_info.route\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "user.service.impl.UserServiceImpl.findByUserId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    userId = log[\"arguments\"][\"userId\"]\n    \n    # Format Check\n    assert uuid_re.match(userId), \"userId should be a UUID\"\n    \n    # Environment Integrity Check\n    assert userId == log[\"env\"][\"user_id\"], \"userId should match the user_id in the env\"\n    \n    # Database Integrity Check\n    for key in [\"auth_user#0\", \"auth_user#1\", \"user#0\", \"user#1\"]:\n        assert userId == log[\"db_info\"][key][\"user_id\"], f\"userId should match the user_id in the db_info.{key}\"\n    \n    # Related Events Check (only if related_events is not empty and contains the expected structure)\n    if log.get(\"related_events\"):\n        contacts_service = log[\"related_events\"].get(\"contacts.service.ContactsServiceImpl.findContactsByAccountId\")\n        if contacts_service and \"response\" in contacts_service and \"data\" in contacts_service[\"response\"]:\n            related_events = contacts_service[\"response\"][\"data\"]\n            assert all(userId == contact[\"accountId\"] for contact in related_events), \"userId should match the accountId in the related_events\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(userId), \"userId should not contain any SQL injection features\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    trip_id = log[\"arguments\"][\"gtdi\"][\"tripId\"]\n    travel_date = log[\"arguments\"][\"gtdi\"][\"travelDate\"]\n    from_location = log[\"arguments\"][\"gtdi\"][\"from\"]\n    to_location = log[\"arguments\"][\"gtdi\"][\"to\"]\n    \n    assert re.match(r\"^[A-Za-z0-9]+$\", trip_id), \"tripId should be a valid train number\"\n    assert re.match(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\", travel_date), \"travelDate should be in the format YYYY-MM-DD or YYYY-MM-DD HH:MM:SS\"\n    assert isinstance(from_location, str) and from_location, \"from should be a non-empty string\"\n    assert isinstance(to_location, str) and to_location, \"to should be a non-empty string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(trip_id), \"tripId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(travel_date), \"travelDate should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(from_location), \"from should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(to_location), \"to should not contain SQL injection features\"\n\n    # Related Events Check\n    if \"related_events\" in log and log[\"related_events\"]:\n        related_events = log[\"related_events\"]\n        if \"other.service.OrderOtherServiceImpl.queryOrders\" in related_events:\n            query_orders = related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"]\n            if query_orders is not None and \"response\" in query_orders and query_orders[\"response\"] is not None:\n                response = query_orders[\"response\"]\n                if \"data\" in response and response[\"data\"] is not None:\n                    related_orders = response[\"data\"]\n                    # No assertions on to_location, from_location, or travel_date\n\n    # Environment Integrity Check\n    if \"related_events\" in log and log[\"related_events\"]:\n        related_events = log[\"related_events\"]\n        if \"other.service.OrderOtherServiceImpl.queryOrders\" in related_events:\n            query_orders = related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"]\n            if query_orders is not None and \"response\" in query_orders and query_orders[\"response\"] is not None:\n                response = query_orders[\"response\"]\n                if \"data\" in response and response[\"data\"] is not None:\n                    related_orders = response[\"data\"]\n                    env_user_id = log[\"env\"][\"user_id\"]\n                    account_ids = [order[\"accountId\"] for order in related_orders]\n                    assert env_user_id in account_ids, \"user_id in env should match the accountId in at least one order\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.queryByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain any SQL injection features\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in the env field\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id in the db_info.auth_user object\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    if \"contacts.service.ContactsServiceImpl.findContactsByAccountId\" in related_events and related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"] is not None:\n        assert log[\"arguments\"][\"accountId\"] == related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"arguments\"][\"accountId\"], \"accountId should be consistent in contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if \"other.service.OrderOtherServiceImpl.queryOrders\" in related_events and related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"] is not None:\n        assert log[\"arguments\"][\"accountId\"] == related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"][\"arguments\"][\"accountId\"], \"accountId should be consistent in other.service.OrderOtherServiceImpl.queryOrders\"\n    if \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\" in related_events and related_events[\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"] is not None:\n        assert log[\"arguments\"][\"accountId\"] == related_events[\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"arguments\"][\"accountId\"], \"accountId should be consistent in other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "com.trainticket.service.PaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT\u6781\u5ba2\u65f6\u95f4|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"info\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"info\"][\"price\"], str), \"price should be a string\"\n    assert re.match(r\"^-?\\d+(\\.\\d+)?$\", log[\"arguments\"][\"info\"][\"price\"]), \"price should be a valid numeric format\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][\"orderId\"]), \"orderId should not contain SQL injection patterns\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][\"price\"]), \"price should not contain SQL injection patterns\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"info\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    assert log[\"arguments\"][\"info\"][\"price\"] == log[\"db_info\"][\"orders\"][\"price\"], \"price should match the price in db_info.orders\"\n\n    # Environment Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"user_id in env should match account_id in db_info.orders\"\n\n    # Status Check\n    status = log[\"db_info\"][\"orders\"][\"status\"]\n    assert status in [0, 1, 3], \"status should be valid for payment operation\"\n\n    # Range Check\n    assert log[\"db_info\"][\"orders\"][\"document_type\"] in [0, 1, 2, 3], \"document_type should be in (0, 1, 2, 3)\"\n    assert log[\"db_info\"][\"orders\"][\"seat_class\"] in [0, 1, 2, 3], \"seat_class should be in (0, 1, 2, 3)\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "assurance.service.AssuranceServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    assert isinstance(log[\"arguments\"][\"typeIndex\"], int), \"typeIndex should be an integer\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Range Check\n    assert 0 <= log[\"arguments\"][\"typeIndex\"] <= 2, \"typeIndex should be within the range 0 to 2\"\n    \n    # Environment Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"env.user_id should match db_info.auth_user.user_id\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.insertConsignRecord", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    consign_request = log[\"arguments\"][\"consignRequest\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n\n    # Format Check\n    assert UUID_RE.match(consign_request[\"orderId\"]), \"orderId should be a UUID\"\n    assert UUID_RE.match(consign_request[\"accountId\"]), \"accountId should be a UUID\"\n    try:\n        datetime.fromisoformat(consign_request[\"handleDate\"])\n        datetime.fromisoformat(consign_request[\"targetDate\"])\n    except ValueError:\n        raise AssertionError(\"handleDate and targetDate should follow ISO 8601 format\")\n    assert isinstance(consign_request[\"weight\"], float) and consign_request[\"weight\"] > 0, \"weight should be a positive float\"\n    assert isinstance(consign_request[\"isWithin\"], bool), \"isWithin should be a boolean\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(consign_request[\"consignee\"]), \"consignee should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"phone\"]), \"phone should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"from\"]), \"from should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(consign_request[\"to\"]), \"to should not contain SQL injection features\"\n\n    # Range Check\n    assert consign_request[\"isWithin\"] in [0, 1], \"isWithin should be either 0 or 1\"\n\n    # Database Integrity Check\n    assert consign_request[\"accountId\"] == db_info[\"user#0\"][\"user_id\"], \"accountId should match the user_id in db_info.user#0\"\n    assert consign_request[\"accountId\"] == db_info[\"user#1\"][\"user_id\"], \"accountId should match the user_id in db_info.user#1\"\n\n    # Environment Integrity Check\n    assert consign_request[\"accountId\"] == env[\"user_id\"], \"accountId should match the user_id in env\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketExecute", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Environment Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    candidate_order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            candidate_order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert log[\"arguments\"][\"orderId\"] in candidate_order_ids, \"orderId should be present in the id fields of the data arrays in the related events\"\n    \n    # Status Check\n    status = log[\"db_info\"][\"orders\"][\"status\"]\n    assert status in [0, 1, 2, 3], \"status should be in (0, 1, 2, 3)\"\n    assert status == 2, \"status should be 2 for execution\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nTRAIN_NUMBER_RE = re.compile(r\"^[A-Za-z]\\d+$\")\nPRICE_RE = re.compile(r\"^-?\\d+(\\.\\d+)?$\")  # Updated to allow more than two decimal places\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    \n    # Format Check\n    assert UUID_RE.match(order[\"id\"]), \"id should be a UUID\"\n    assert UUID_RE.match(order[\"accountId\"]), \"accountId should be a UUID\"\n    assert UUID_RE.match(log[\"env\"][\"user_id\"]), \"user_id should be a UUID\"\n    assert datetime.strptime(order[\"boughtDate\"], \"%Y-%m-%d %H:%M:%S\"), \"boughtDate should be in ISO 8601 format\"\n    assert datetime.strptime(order[\"travelDate\"], \"%Y-%m-%d\"), \"travelDate should be in ISO 8601 format\"\n    assert datetime.strptime(order[\"travelTime\"], \"%Y-%m-%d %H:%M:%S\"), \"travelTime should be in ISO 8601 format\"\n    assert TRAIN_NUMBER_RE.match(order[\"trainNumber\"]), \"trainNumber should follow the format (e.g., D5339)\"\n    assert PRICE_RE.match(order[\"price\"]), \"price should be a valid monetary value\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(order[\"contactsName\"]), \"contactsName should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"contactsDocumentNumber\"]), \"contactsDocumentNumber should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"from\"]), \"from should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"to\"]), \"to should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(order[\"seatNumber\"]), \"seatNumber should not contain SQL injection features\"\n    \n    # Range Check\n    assert order[\"documentType\"] in (0, 1, 2, 3), \"documentType should be in (0, 1, 2, 3)\"\n    assert order[\"seatClass\"] in (0, 1, 2, 3), \"seatClass should be in (0, 1, 2, 3)\"\n    assert order[\"coachNumber\"] > 0, \"coachNumber should be a positive integer\"\n    assert order[\"status\"] in (0, 1, 2, 3), \"status should be in (0, 1, 2, 3)\"\n    \n    # Database Integrity Check\n    assert order[\"accountId\"] == log[\"db_info\"][\"user#0\"][\"user_id\"], \"accountId should match user_id in db_info\"\n    \n    # Environment Integrity Check\n    assert order[\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match user_id in env\"\n    \n    # Related Events Check\n    related_contacts = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    assert any(contact[\"accountId\"] == order[\"accountId\"] for contact in related_contacts), \"accountId should match accountId in related_events\"\n    \n    # Status Check\n    if order[\"status\"] in (0, 1, 3):\n        pass  # Can be refunded\n    if order[\"status\"] == 1:\n        pass  # Can be collected\n    if order[\"status\"] == 2:\n        pass  # Can be executed\n    \n    # Train Number Check\n    # Assuming no specific train number check in related_events, so no assertion here\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketCollect", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Environment Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    order_ids = []\n    for event in related_events.values():\n        if \"response\" in event and \"data\" in event[\"response\"]:\n            order_ids.extend([order[\"id\"] for order in event[\"response\"][\"data\"]])\n    assert log[\"arguments\"][\"orderId\"] in order_ids, \"orderId should be present in the related events\"\n    \n    # Status Check\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 1, \"order status should be 1 for collection\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "consignprice.service.ConsignPriceServiceImpl.getPriceByWeightAndRegion", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"weight\"], float), \"weight should be a float\"\n    assert isinstance(log[\"arguments\"][\"isWithinRegion\"], bool), \"isWithinRegion should be a boolean\"\n    \n    # Range Check\n    assert log[\"arguments\"][\"weight\"] > 0, \"weight should be greater than 0\"\n    \n    # Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n    \n    # Environment Integrity Check (only if insertConsignRecord exists and is not None)\n    if \"consign.service.ConsignServiceImpl.insertConsignRecord\" in log[\"related_events\"]:\n        insert_event = log[\"related_events\"][\"consign.service.ConsignServiceImpl.insertConsignRecord\"]\n        if insert_event is not None and insert_event.get(\"arguments\") and insert_event[\"arguments\"].get(\"consignRequest\"):\n            assert log[\"env\"][\"user_id\"] == insert_event[\"arguments\"][\"consignRequest\"][\"accountId\"], \"user_id in env should match accountId in related_events.consign.service.ConsignServiceImpl.insertConsignRecord.arguments.consignRequest\"\n    \n    # Environment Database Integrity Check (only if queryByAccountId exists and is not None)\n    if \"consign.service.ConsignServiceImpl.queryByAccountId\" in log[\"related_events\"]:\n        query_event = log[\"related_events\"][\"consign.service.ConsignServiceImpl.queryByAccountId\"]\n        if query_event is not None and query_event.get(\"response\") and query_event[\"response\"].get(\"data\"):\n            for data in query_event[\"response\"][\"data\"]:\n                assert log[\"env\"][\"user_id\"] == data[\"accountId\"], \"user_id in env should match accountId in related_events.consign.service.ConsignServiceImpl.queryByAccountId.response.data\"\n    \n    # Vulnerability Check\n    for key, value in log[\"arguments\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"]\n    qi = arguments[\"qi\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert isinstance(arguments[\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(qi[\"loginId\"], str), \"loginId should be a string\"\n    assert qi[\"travelDateStart\"] is None or isinstance(qi[\"travelDateStart\"], str), \"travelDateStart should be null or a string\"\n    assert qi[\"travelDateEnd\"] is None or isinstance(qi[\"travelDateEnd\"], str), \"travelDateEnd should be null or a string\"\n    assert qi[\"boughtDateStart\"] is None or isinstance(qi[\"boughtDateStart\"], str), \"boughtDateStart should be null or a string\"\n    assert qi[\"boughtDateEnd\"] is None or isinstance(qi[\"boughtDateEnd\"], str), \"boughtDateEnd should be null or a string\"\n    assert isinstance(qi[\"state\"], int), \"state should be an integer\"\n    assert isinstance(qi[\"enableTravelDateQuery\"], bool), \"enableTravelDateQuery should be a boolean\"\n    assert isinstance(qi[\"enableBoughtDateQuery\"], bool), \"enableBoughtDateQuery should be a boolean\"\n    assert isinstance(qi[\"enableStateQuery\"], bool), \"enableStateQuery should be a boolean\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(arguments[\"accountId\"]), \"accountId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(qi[\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # Range Check\n    assert qi[\"state\"] in (0, 1, 2, 3), \"state should be within the valid range (0, 1, 2, 3)\"\n\n    # Database Integrity Check\n    assert arguments[\"accountId\"] == db_info[\"auth_user\"][\"user_id\"], \"accountId should match the user_id in db_info.auth_user\"\n    assert qi[\"loginId\"] == db_info[\"auth_user\"][\"user_id\"], \"loginId should match the user_id in db_info.auth_user\"\n\n    # Environment Integrity Check\n    assert arguments[\"accountId\"] == env[\"user_id\"], \"accountId should match the user_id in env\"\n\n    # Related Events Check\n    for event in related_events[\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"data\"]:\n        assert arguments[\"accountId\"] == event[\"accountId\"], \"accountId should match the accountId in related_events.order.service.OrderServiceImpl.queryOrders.response.data\"\n\n    # Status Check\n    if qi[\"state\"] is not None:\n        assert qi[\"state\"] in (0, 1, 3), \"state should be valid for the current operation\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check: accountId and loginId should be valid strings and not contain SQL injection\n    assert isinstance(log[\"arguments\"][\"accountId\"], str), \"accountId should be a string\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection features\"\n    \n    qi = log[\"arguments\"][\"qi\"]\n    assert isinstance(qi[\"loginId\"], str), \"loginId should be a string\"\n    assert not SQL_INJECTION_RE.search(qi[\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # Range Check: state should be in (0, 1, 2, 3)\n    assert qi[\"state\"] in {0, 1, 2, 3}, \"state should be in (0, 1, 2, 3)\"\n\n    # Environment Integrity Check: accountId should match user_id in env\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match user_id in env\"\n\n    # Database Integrity Check: loginId should match one of the user_id fields in db_info\n    user_ids = [user[\"user_id\"] for user in log[\"db_info\"].values()]\n    assert qi[\"loginId\"] in user_ids, \"loginId should match one of the user_id fields in db_info\"\n\n    # Related Events Check: accountId should match accountId in related events' responses\n    for event in log[\"related_events\"].values():\n        for order in event[\"response\"][\"data\"]:\n            assert log[\"arguments\"][\"accountId\"] == order[\"accountId\"], \"accountId should match accountId in related events' responses\"\n\n    # Status Check: state should be valid for current operation\n    if qi[\"enableStateQuery\"]:\n        assert qi[\"state\"] in {0, 1, 3}, \"state should be in (0, 1, 3) for refund operation\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n\n    # Format Check\n    assert isinstance(order[\"id\"], str), \"id should be a string\"\n    assert isinstance(order[\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(order[\"contactsDocumentNumber\"], str), \"contactsDocumentNumber should be a string\"\n    assert isinstance(order[\"trainNumber\"], str), \"trainNumber should be a string\"\n    assert isinstance(order[\"seatNumber\"], str), \"seatNumber should be a string\"\n    assert isinstance(order[\"from\"], str), \"from should be a string\"\n    assert isinstance(order[\"to\"], str), \"to should be a string\"\n    assert isinstance(order[\"price\"], str), \"price should be a string\"\n\n    try:\n        datetime.strptime(order[\"boughtDate\"], \"%Y-%m-%d %H:%M:%S\")\n        datetime.strptime(order[\"travelDate\"], \"%Y-%m-%d\")\n        datetime.strptime(order[\"travelTime\"], \"%Y-%m-%d %H:%M:%S\")\n    except ValueError:\n        raise AssertionError(\"Date fields should follow the correct format\")\n\n    assert isinstance(order[\"documentType\"], int), \"documentType should be an integer\"\n    assert isinstance(order[\"coachNumber\"], int), \"coachNumber should be an integer\"\n    assert isinstance(order[\"seatClass\"], int), \"seatClass should be an integer\"\n    assert isinstance(order[\"status\"], int), \"status should be an integer\"\n\n    # Vulnerability Check\n    for field in [order[\"id\"], order[\"accountId\"], order[\"contactsDocumentNumber\"], order[\"trainNumber\"], order[\"seatNumber\"], order[\"from\"], order[\"to\"], order[\"price\"]]:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain any SQL injection features\"\n\n    # Range Check\n    assert order[\"documentType\"] in (0, 1, 2, 3), \"documentType should be in (0, 1, 2, 3)\"\n    assert order[\"seatClass\"] in (0, 1, 2, 3), \"seatClass should be in (0, 1, 2, 3)\"\n    assert order[\"status\"] in (0, 1, 2, 3), \"status should be in (0, 1, 2, 3)\"\n\n    # Database Integrity Check\n    assert order[\"accountId\"] == db_info[\"user\"][\"user_id\"], \"accountId should match user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert order[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n\n    # Related Events Check\n    found = False\n    for contact in related_events:\n        if contact[\"documentNumber\"] == order[\"contactsDocumentNumber\"] and contact[\"documentType\"] == order[\"documentType\"]:\n            found = True\n            break\n    assert found, \"contactsDocumentNumber and documentType should match in related_events\"\n\n    # Status Check\n    assert order[\"status\"] in (0, 1, 3), \"status should be valid for the current operation\"\n\n    # Price Check\n    try:\n        float(order[\"price\"])\n    except ValueError:\n        raise AssertionError(\"price should be a valid decimal number\")\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check: orderId should be a UUID\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # Vulnerability Check: orderId should not contain SQL injection patterns\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection patterns\"\n    \n    # Database Integrity Check: orderId should match the id field in db_info.orders\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id field in db_info.orders\"\n    \n    # Related Events Check: orderId should be present in the id fields of the data array in related_events\n    if \"related_events\" in log and isinstance(log[\"related_events\"], dict) and log[\"related_events\"]:\n        if \"other.service.OrderOtherServiceImpl.queryOrders\" in log[\"related_events\"] and isinstance(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"], dict) and \"response\" in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"] and isinstance(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"], dict) and \"data\" in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"]:\n            order_ids_query_orders = [order[\"id\"] for order in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"data\"]]\n            assert log[\"arguments\"][\"orderId\"] in order_ids_query_orders, \"orderId should be present in the id fields of the data array in related_events.other.service.OrderOtherServiceImpl.queryOrders.response\"\n        if \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\" in log[\"related_events\"] and isinstance(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"], dict) and \"response\" in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"] and isinstance(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"], dict) and \"data\" in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"]:\n            order_ids_query_orders_for_refresh = [order[\"id\"] for order in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"]]\n            assert log[\"arguments\"][\"orderId\"] in order_ids_query_orders_for_refresh, \"orderId should be present in the id fields of the data array in related_events.other.service.OrderOtherServiceImpl.queryOrdersForRefresh.response\"\n    \n    # Status Check: status in db_info.orders should be valid for the current operation\n    assert log[\"db_info\"][\"orders\"][\"status\"] in {0, 1, 2, 3}, \"status in db_info.orders should be valid for the current operation\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.getAllFood", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    assert date_re.match(log[\"arguments\"][\"date\"]), \"date should be in YYYY-MM-DD format\"\n    \n    # Vulnerability Check\n    for field in [\"date\", \"startStation\", \"endStation\", \"tripId\"]:\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][field]), f\"{field} should not contain SQL injection features\"\n    \n    # Environment Integrity Check (only if related_events and its nested keys exist)\n    if log.get(\"related_events\"):\n        user_id = log[\"env\"][\"user_id\"]\n        related_orders = []\n        \n        # Check if each nested key exists before accessing it\n        if log[\"related_events\"].get(\"order.service.OrderServiceImpl.queryOrders\") and log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"].get(\"response\"):\n            related_orders.extend(log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"response\"].get(\"data\", []))\n        \n        if log[\"related_events\"].get(\"other.service.OrderOtherServiceImpl.queryOrders\") and log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"].get(\"response\"):\n            related_orders.extend(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"].get(\"data\", []))\n        \n        if log[\"related_events\"].get(\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\") and log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"].get(\"response\"):\n            related_orders.extend(log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"].get(\"data\", []))\n        \n        # Perform the check only if related_orders is not empty\n        if related_orders:\n            account_ids = [order[\"accountId\"] for order in related_orders]\n            assert user_id in account_ids, \"user_id in env should match the accountId in the related events' order data\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check: orderId should be a UUID\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # Vulnerability Check: orderId should not contain SQL injection features\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    \n    # Database Integrity Check: orderId should match the id in db_info.orders\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in db_info.orders\"\n    \n    # Status Check: status in db_info.orders should be valid for the current operation\n    current_status = log[\"db_info\"][\"orders\"][\"status\"]\n    if log[\"arguments\"][\"status\"] == 0 or log[\"arguments\"][\"status\"] == 1 or log[\"arguments\"][\"status\"] == 3:\n        assert current_status in {0, 1, 3}, \"status in db_info.orders should be valid for refund operation\"\n    elif log[\"arguments\"][\"status\"] == 1:\n        assert current_status == 1, \"status in db_info.orders should be valid for collect operation\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "seat.service.SeatServiceImpl.distributeSeat", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    try:\n        datetime.strptime(log[\"arguments\"][\"seatRequest\"][\"travelDate\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise ValueError(\"travelDate should be in the format YYYY-MM-DD\")\n    \n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"trainNumber\"], str), \"trainNumber should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"startStation\"], str), \"startStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"destStation\"], str), \"destStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"seatType\"], int), \"seatType should be an integer\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"totalNum\"], int), \"totalNum should be an integer\"\n    assert log[\"arguments\"][\"seatRequest\"][\"totalNum\"] > 0, \"totalNum should be greater than 0\"\n    assert isinstance(log[\"arguments\"][\"seatRequest\"][\"stations\"], list), \"stations should be a list\"\n    for station in log[\"arguments\"][\"seatRequest\"][\"stations\"]:\n        assert isinstance(station, str), \"stations should contain only strings\"\n\n    # Vulnerability Check\n    for field in [\"trainNumber\", \"startStation\", \"destStation\"]:\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"seatRequest\"][field]), f\"{field} should not contain any SQL injection features\"\n    for station in log[\"arguments\"][\"seatRequest\"][\"stations\"]:\n        assert not SQL_INJECTION_RE.search(station), \"stations should not contain any SQL injection features\"\n\n    # Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"user_id in env should match user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match user_id in db_info.auth_user\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "cancel.service.CancelServiceImpl.cancelOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"loginId\"], str), \"loginId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id field in db_info.orders\"\n    assert log[\"arguments\"][\"loginId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"loginId should match the user_id field in db_info.auth_user\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"loginId\"] == log[\"env\"][\"user_id\"], \"loginId should match the user_id field in env\"\n\n    # Status Check\n    order_status = log[\"db_info\"][\"orders\"][\"status\"]\n    assert order_status in {0, 1, 3}, \"order status should be 0, 1, or 3 for cancellation\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "rebook.service.RebookServiceImpl.updateOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"order\"][\"id\"]), \"order.id should be a UUID\"\n    assert uuid_re.match(log[\"arguments\"][\"order\"][\"accountId\"]), \"order.accountId should be a UUID\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"order\"][\"contactsName\"]), \"contactsName should not contain any SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"order\"][\"contactsDocumentNumber\"]), \"contactsDocumentNumber should not contain any SQL injection features\"\n\n    # Range Check\n    assert log[\"arguments\"][\"order\"][\"documentType\"] in (0, 1, 2, 3), \"documentType should be in (0, 1, 2, 3)\"\n    assert log[\"arguments\"][\"order\"][\"seatClass\"] in (0, 1, 2, 3), \"seatClass should be in (0, 1, 2, 3)\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"order\"][\"accountId\"] in [log[\"db_info\"][\"auth_user\"][\"user_id\"], log[\"db_info\"][\"user#0\"][\"user_id\"], log[\"db_info\"][\"user#1\"][\"user_id\"]], \"order.accountId should match the user_id in db_info\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"order\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"order.accountId should match env.user_id\"\n\n    # Status Check\n    assert log[\"arguments\"][\"order\"][\"status\"] in (0, 1, 2, 3, 4, 6), \"order.status should be in (0, 1, 2, 3, 4, 6)\"\n\n    # Train Number Check\n    if \"info\" in log[\"arguments\"] and log[\"arguments\"][\"info\"] is not None and \"oldTripId\" in log[\"arguments\"][\"info\"]:\n        assert log[\"arguments\"][\"order\"][\"trainNumber\"] == log[\"arguments\"][\"info\"][\"oldTripId\"], \"order.trainNumber should match info.oldTripId\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "preserve.service.PreserveServiceImpl.preserve", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nPHONE_RE = re.compile(r\"^\\+?[1-9]\\d{1,14}$\")\nDATE_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n\ndef check(log: dict) -> bool:\n    oti = log[\"arguments\"][\"oti\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert UUID_RE.match(oti[\"accountId\"]), \"account\u6781\u5ba2\u65f6\u95f4Id should be a UUID\"\n    assert UUID_RE.match(oti[\"contactsId\"]), \"contactsId should be a UUID\"\n    assert DATE_RE.match(oti[\"date\"]), \"date should be in YYYY-MM-DD format\"\n    if \"handleDate\" in oti and oti[\"handleDate\"] is not None:\n        assert DATE_RE.match(oti[\"handleDate\"]), \"handleDate should be in YYYY-MM-DD format\"\n    if \"consigneePhone\" in oti and oti[\"consigneePhone\"] is not None:\n        assert PHONE_RE.match(oti[\"consigneePhone\"]), \"consigneePhone should be a valid phone number\"\n\n    # Vulnerability Check\n    if \"consigneeName\" in oti and oti[\"consigneeName\"] is not None:\n        assert not SQL_INJECTION_RE.search(oti[\"consigneeName\"]), \"consigneeName should not contain SQL injection features\"\n    if \"stationName\" in oti and oti[\"stationName\"] is not None:\n        assert not SQL_INJECTION_RE.search(oti[\"stationName\"]), \"stationName should not contain SQL injection features\"\n    if \"storeName\" in oti and oti[\"storeName\"] is not None:\n        assert not SQL_INJECTION_RE.search(oti[\"storeName\"]), \"storeName should not contain SQL injection features\"\n    if \"foodName\" in oti and oti[\"foodName\"] is not None:\n        assert not SQL_INJECTION_RE.search(oti[\"foodName\"]), \"foodName should not contain SQL injection features\"\n    if \"consigneePhone\" in oti and oti[\"consigneePhone\"] is not None:\n        assert not SQL_INJECTION_RE.search(oti[\"consigneePhone\"]), \"consigneePhone should not contain SQL injection features\"\n\n    # Range Check\n    assert oti[\"seatType\"] in (0, 1, 2, 3), \"seatType should be 0, 1, 2, or 3\"\n    assert oti[\"assurance\"] in (0, 1, 2, 3), \"assurance should be 0, 1, 2, or 3\"\n    assert oti[\"foodType\"] in (0, 1, 2), \"foodType should be 0, 1, or 2\"\n    assert oti[\"isWithin\"] in (0, 1), \"isWithin should be 0 or 1\"\n    if \"consigneeWeight\" in oti and oti[\"consigneeWeight\"] is not None:\n        assert 0 <= oti[\"consigneeWeight\"] <= 100, \"consigneeWeight should be between 0 and 100\"\n\n    # Database Integrity Check\n    if \"contacts\" in db_info and db_info[\"contacts\"] is not None:\n        assert oti[\"accountId\"] == db_info[\"contacts\"][\"account_id\"], \"accountId should match account_id in db_info.contacts\"\n    assert oti[\"accountId\"] == db_info[\"user\"][\"user_id\"], \"accountId should match user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert oti[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n\n    # Range Check for documentType and seatType\n    if \"contacts\" in db_info and db_info[\"contacts\"] is not None:\n        assert db_info[\"contacts\"][\"document_type\"] in (0, 1, 2, 3), \"documentType should be 0, 1, 2, or 3\"\n    assert oti[\"seatType\"] in (0, 1, 2, 3), \"seatType should be 0, 1, 2, or 3\"\n\n    return True\n", "num_args": 1}}
