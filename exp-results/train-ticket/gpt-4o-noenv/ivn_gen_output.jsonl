{"domain": [{"api": "security.service.SecurityServiceImpl.check", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\n    # Format Check: accountId should be a UUID\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n\n    # Vulnerability Check: Ensure no SQL injection in accountId\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection features\"\n\n    # Related Events Check: accountId in arguments should match accountId in related_events.arguments\n    assert log[\"arguments\"][\"accountId\"] == log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"arguments\"][\"accountId\"], \\\n        \"accountId in arguments should match accountId in related_events.arguments\"\n\n    # Related Events Check: accountId should be one of the accountIds in the related_events response data\n    response_data_account_ids = [\n        data[\"accountId\"] for data in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    ]\n    assert log[\"arguments\"][\"accountId\"] in response_data_account_ids, \\\n        \"accountId should be one of the accountIds in the related_events response data\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nDATETIME_FORMAT = \"%Y-%m-%d %H:%M:%S\"\nDATE_FORMAT = \"%Y-%m-%d\"\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    db_user = log[\"db_info\"][\"user\"]\n    related_contacts = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n\n    # UUID Format Check\n    assert UUID_RE.match(order[\"id\"]), \"order.id should be a UUID\"\n    assert UUID_RE.match(order[\"accountId\"]), \"order.accountId should be a UUID\"\n\n    # Date and Time Format Check\n    try:\n        datetime.strptime(order[\"boughtDate\"], DATETIME_FORMAT)\n    except ValueError:\n        raise AssertionError(\"order.boughtDate should match the format 'YYYY-MM-DD HH:MM:SS'\")\n\n    try:\n        datetime.strptime(order[\"travelDate\"], DATE_FORMAT)\n    except ValueError:\n        raise AssertionError(\"order.travelDate should match the format 'YYYY-MM-DD'\")\n\n    try:\n        datetime.strptime(order[\"travelTime\"], DATETIME_FORMAT)\n    except ValueError:\n        raise AssertionError(\"order.travelTime should match the format 'YYYY-MM-DD HH:MM:SS'\")\n\n    # Status Value Check\n    assert order[\"status\"] == 0, \"order.status should be 0\"\n    # Initial status guess: 0\n\n    # AccountId Integrity Check\n    assert order[\"accountId\"] == db_user[\"user_id\"], \"order.accountId should match db_info.user.user_id\"\n    account_ids = {contact[\"accountId\"] for contact in related_contacts}\n    assert order[\"accountId\"] in account_ids, \"order.accountId should be one of the accountIds in related_events\"\n\n    # Vulnerability Check\n    fields_to_check = [\"contactsName\", \"contactsDocumentNumber\", \"trainNumber\", \"from\", \"to\", \"seatNumber\"]\n    for field in fields_to_check:\n        assert not SQL_INJECTION_RE.search(order[field]), f\"order.{field} should not contain any SQL injection features\"\n\n    # Document Number and Type Consistency Check\n    document_consistency = any(order[\"contactsDocumentNumber\"] == contact[\"documentNumber\"] and order[\"documentType\"] == contact[\"documentType\"] for contact in related_contacts)\n    assert document_consistency, \"order.contactsDocumentNumber and order.documentType should match a record in related_events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "rebook.service.RebookServiceImpl.rebook", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Check 1: Format Check for 'date'\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    assert date_re.match(log[\"arguments\"][\"info\"][\"date\"]), \"date should follow 'YYYY-MM-DD' format\"\n    \n    # Check 2: SQL Injection Check\n    for key, value in log[\"arguments\"][\"info\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n    \n    # Check 3: Argument and Database Status Check\n    # Past status feedback: 1\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 1, \"order status in db_info should be 1\"\n    \n    # Check 4: Database Integrity Check\n    assert log[\"arguments\"][\"info\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match id in db_info.orders\"\n    \n    # Check 5: Environment Integrity Check\n    if log[\"arguments\"][\"info\"][\"loginId\"]:\n        assert log[\"arguments\"][\"info\"][\"loginId\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"loginId should match account_id in db_info.orders\"\n    \n    # Check 6: Related Events Check\n    related_order_ids = []\n    for service in [\"order.service.OrderServiceImpl.queryOrders\", \n                    \"order.service.OrderServiceImpl.queryOrdersForRefresh\", \n                    \"other.service.OrderOtherServiceImpl.queryOrders\", \n                    \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"]:\n        if service in log[\"related_events\"]:\n            related_order_ids.extend(order[\"id\"] \n                                     for order in log[\"related_events\"][service][\"response\"][\"data\"])\n    assert log[\"arguments\"][\"info\"][\"orderId\"] in related_order_ids, \"orderId should be present in related events order ids\"\n    \n    # Check 7: Environment Database Integrity Check\n    related_account_ids = [\n        order[\"accountId\"]\n        for order in log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"data\"]\n    ]\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] in related_account_ids, \"account_id in db_info should match one in related events\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "inside_payment.service.InsidePaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\nPRICE_FORMAT_RE = re.compile(r\"^\\d+(\\.\\d{1,2})?$\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    if log[\"arguments\"][\"info\"].get(\"price\") is not None:\n        assert isinstance(log[\"arguments\"][\"info\"][\"price\"], str), \"price should be a string\"\n        assert PRICE_FORMAT_RE.match(log[\"arguments\"][\"info\"][\"price\"]), \"price should be in a numeric format\"\n\n    # Vulnerability Check\n    for field in [\"userId\", \"orderId\", \"tripId\", \"price\"]:\n        if log[\"arguments\"][\"info\"].get(field) is not None:\n            assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"info\"][field]), f\"{field} should not contain any SQL injection features\"\n\n    # Argument and Database Status Check\n    # Past status Feedback: 0\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 0, \"status in db_info.orders should be 0\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"info\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId in arguments.info should match id in db_info.orders\"\n    if log[\"arguments\"][\"info\"].get(\"price\") is not None:\n        assert log[\"arguments\"][\"info\"][\"price\"] == log[\"db_info\"][\"orders\"][\"price\"], \"price in arguments.info should match price in db_info.orders\"\n\n    # Related Events Check\n    related_ids = [\n        event[\"id\"] for event in log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"data\"]\n    ]\n    related_ids += [\n        event[\"id\"] for event in log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"]\n    ]\n    related_ids += [\n        event[\"id\"] for event in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"data\"]\n    ]\n    related_ids += [\n        event[\"id\"] for event in log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"]\n    ]\n    assert log[\"arguments\"][\"info\"][\"orderId\"] in related_ids, \"orderId in arguments.info should be in related_events\"\n\n    # Environment Database Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"arguments\"][\"accountId\"], \"account_id in db_info.orders should match accountId in related_events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n    string_fields = [\n        log[\"arguments\"][\"gtdi\"][\"tripId\"], \n        log[\"arguments\"][\"gtdi\"][\"from\"], \n        log[\"arguments\"][\"gtdi\"][\"to\"], \n        log[\"arguments\"][\"gtdi\"][\"travelDate\"]\n    ]\n\n    # Format check for travelDate\n    assert date_re.match(log[\"arguments\"][\"gtdi\"][\"travelDate\"]), \"travelDate should follow YYYY-MM-DD or YYYY-MM-DD HH:MM:SS format\"\n\n    # Check that tripId, from, and to fields are strings\n    for field in string_fields:\n        assert isinstance(field, str), f\"{field} should be a string\"\n\n    # Vulnerability check for SQL injection\n    for field in string_fields:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain SQL injection keywords\"\n\n    # Related events check\n    related_events = log.get(\"related_events\", {})\n    if isinstance(related_events, dict):\n        query_orders = related_events.get(\"other.service.OrderOtherServiceImpl.queryOrders\", {})\n        if isinstance(query_orders, dict):\n            response = query_orders.get(\"response\", {})\n            related_data = response.get(\"data\", [])\n\n            if isinstance(related_data, list) and related_data:\n                valid_trip_ids = [item[\"trainNumber\"] for item in related_data]\n                valid_from_locations = [item[\"from\"] for item in related_data]\n                valid_to_locations = [item[\"to\"] for item in related_data]\n                valid_travel_dates = [item[\"travelDate\"] for item in related_data]\n\n                # Perform checks only if data is present and tripId is in related_data\n                if valid_trip_ids and log[\"arguments\"][\"gtdi\"][\"tripId\"] in valid_trip_ids:\n                    assert log[\"arguments\"][\"gtdi\"][\"tripId\"] in valid_trip_ids, \"tripId should match a trainNumber in related events\"\n                if valid_from_locations and log[\"arguments\"][\"gtdi\"][\"from\"] in valid_from_locations:\n                    assert log[\"arguments\"][\"gtdi\"][\"from\"] in valid_from_locations, \"from should match a from field in related events\"\n                if valid_to_locations and log[\"arguments\"][\"gtdi\"][\"to\"] in valid_to_locations:\n                    assert log[\"arguments\"][\"gtdi\"][\"to\"] in valid_to_locations, \"to should match a to field in related events\"\n                if valid_travel_dates and log[\"arguments\"][\"gtdi\"][\"travelDate\"] in valid_travel_dates:\n                    assert log[\"arguments\"][\"gtdi\"][\"travelDate\"] in valid_travel_dates, \"travelDate should match a travelDate in related events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Regex to match UUID format\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\n    # Check if accountId is a valid UUID\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n\n    # Check for SQL Injection vulnerabilities in accountId\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # Format and Vulnerability Check\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection\"\n    \n    assert UUID_RE.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should not contain SQL injection\"\n\n    # Range Check\n    state = log[\"arguments\"][\"qi\"][\"state\"]\n    assert isinstance(state, int) and 0 <= state <= 5, \"state should be between 0 and 5\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match user_id in db_info\"\n    assert log[\"arguments\"][\"qi\"][\"loginId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"loginId should match user_id in db_info\"\n\n    # Related Events Check\n    for event_name in [\"order.service.OrderServiceImpl.queryOrders\", \n                       \"other.service.OrderOtherServiceImpl.queryOrders\", \n                       \"order.service.OrderServiceImpl.getOrderById\",\n                       \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"]:\n        related_event = log[\"related_events\"].get(event_name)\n\n        if not related_event:\n            continue\n\n        # Safely get response and ensure it is not None\n        response = related_event.get(\"response\")\n        if not response:\n            continue\n\n        # Get response data and ensure it is a list\n        response_data = response.get(\"data\", [])\n        if response_data is None:\n            response_data = []\n\n        if not isinstance(response_data, list):\n            response_data = [response_data]  # Handle singular response as list\n\n        for data in response_data:\n            if not isinstance(data, dict):\n                continue\n\n            assert log[\"arguments\"][\"accountId\"] == data.get(\"accountId\"), f\"accountId should match {event_name} response accountId\"\n\n            if log[\"arguments\"][\"qi\"][\"enableStateQuery\"] == 1:\n                assert log[\"arguments\"][\"qi\"][\"state\"] == data.get(\"status\"), f\"state should match {event_name} response status\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"id\"]), \"id should be a UUID\"\n    \n    # Checking related events\n    related_event = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"]\n    \n    # Status check\n    assert related_event[\"response\"][\"status\"] == 1, \"status should be 1 in related events response\"  # Initial status guess: 1\n    \n    # Database integrity check\n    candidate_ids = [data[\"id\"] for data in related_event[\"response\"][\"data\"]]\n    assert log[\"arguments\"][\"id\"] in candidate_ids, \"id in arguments should match one of the id fields in the data array of related events response\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "user.service.impl.UserServiceImpl.findByUserId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    # Format Check\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"userId\"]), \"userId should be a UUID\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"userId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"userId should match auth_user.user_id in db_info\"\n    assert log[\"arguments\"][\"userId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"userId should match user.user_id in db_info\"\n\n    # Related Events Check\n    related_event_key = \"contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if related_event_key in log[\"related_events\"] and log[\"related_events\"][related_event_key]:\n        related_event = log[\"related_events\"][related_event_key]\n        if related_event[\"arguments\"] and \"accountId\" in related_event[\"arguments\"]:\n            assert log[\"arguments\"][\"userId\"] == related_event[\"arguments\"][\"accountId\"], \"userId should match accountId in related_events.arguments\"\n        \n        if related_event[\"response\"] and \"data\" in related_event[\"response\"]:\n            related_account_ids = [entry[\"accountId\"] for entry in related_event[\"response\"][\"data\"]]\n            assert log[\"arguments\"][\"userId\"] in related_account_ids, \"userId should be present as accountId in related_events.response.data\"\n\n    # Argument and Database Status Check\n    # Past status feedback: 1\n    if related_event_key in log[\"related_events\"] and log[\"related_events\"][related_event_key]:\n        related_event = log[\"related_events\"][related_event_key]\n        if related_event[\"response\"] and \"status\" in related_event[\"response\"]:\n            assert related_event[\"response\"][\"status\"] == 1, \"related events response status should be 1\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef is_valid_date(date_str):\n    if date_str is None:\n        return True\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    return date_re.match(date_str) is not None\n\ndef check(log: dict) -> bool:\n    args = log[\"arguments\"]\n    qi = args[\"qi\"]\n    accountId = args[\"accountId\"]\n    \n    # 1. Format Check\n    assert isinstance(accountId, str), \"accountId should be a string\"\n    assert isinstance(qi[\"loginId\"], str), \"loginId should be a string\"\n    assert is_valid_date(qi[\"boughtDateEnd\"]), \"boughtDateEnd should be null or a valid date\"\n    assert is_valid_date(qi[\"boughtDateStart\"]), \"boughtDateStart should be null or a valid date\"\n    assert is_valid_date(qi[\"travelDateEnd\"]), \"travelDateEnd should be null or a valid date\"\n    assert is_valid_date(qi[\"travelDateStart\"]), \"travelDateStart should be null or a valid date\"\n    assert isinstance(qi[\"state\"], int), \"state should be an integer\"\n    assert isinstance(qi[\"enableTravelDateQuery\"], (int, bool)), \"enableTravelDateQuery should be an integer or a boolean\"\n    assert isinstance(qi[\"enableBoughtDateQuery\"], (int, bool)), \"enableBoughtDateQuery should be an integer or a boolean\"\n    assert isinstance(qi[\"enableStateQuery\"], (int, bool)), \"enableStateQuery should be an integer or a boolean\"\n    \n    # 2. Vulnerability Check\n    assert not SQL_INJECTION_RE.search(qi[\"loginId\"]), \"loginId should not contain any SQL injection features\"\n    \n    # 3. Range Check - Not applicable\n    \n    # 4. Argument and Database Status Check\n    observed_statuses = set()\n    for related_event in log[\"related_events\"].values():\n        if related_event and isinstance(related_event, dict):  # Ensure related_event is not None and is a dictionary\n            response = related_event.get(\"response\")\n            if response and isinstance(response, dict) and \"data\" in response and response[\"data\"]:\n                for response_data in response[\"data\"]:\n                    observed_statuses.add(response_data[\"status\"])\n    \n    # Past status feedback: 1, 4, 6, 0, 2, 3\n    known_statuses = {0, 1, 2, 3, 4, 6}\n    assert all(status in known_statuses for status in observed_statuses), f\"Unknown status found in response data: {observed_statuses - known_statuses}\"\n    \n    # 5. Database Integrity Check\n    for related_event in log[\"related_events\"].values():\n        if related_event and isinstance(related_event, dict):\n            response = related_event.get(\"response\")\n            if response and isinstance(response, dict) and \"data\" in response and response[\"data\"]:\n                for response_data in response[\"data\"]:\n                    assert response_data[\"accountId\"] == accountId, \"accountId should match in arguments and response data\"\n                    # Remove the check comparing contactsDocumentNumber with loginId based on feedback\n    \n    # 6. Environment Integrity Check - Not applicable\n    \n    # 7. Related Events Check\n    for related_event in log[\"related_events\"].values():\n        if related_event and isinstance(related_event, dict):\n            assert related_event[\"arguments\"][\"accountId\"] == accountId, \"accountId should match in arguments and related events\"\n            assert related_event[\"arguments\"][\"qi\"][\"loginId\"] == qi[\"loginId\"], \"loginId should match in arguments and related events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.insertConsignRecord", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    consignRequest = log[\"arguments\"][\"consignRequest\"]\n    \n    # UUID format check\n    for field in [\"id\", \"orderId\", \"accountId\"]:\n        if consignRequest[field]:  # Checking if the field is not empty\n            assert UUID_RE.match(consignRequest[field]), f\"{field} should be a UUID\"\n\n    # SQL Injection vulnerability check\n    for field in [\"consignee\", \"from\", \"to\", \"phone\"]:\n        assert not SQL_INJECTION_RE.search(consignRequest[field]), f\"{field} should not contain SQL injection features\"\n\n    # Range Check\n    assert isinstance(consignRequest[\"weight\"], float) and consignRequest[\"weight\"] > 0, \"weight should be a positive float\"\n\n    # Database integrity check\n    if \"orders\" in log[\"db_info\"] and log[\"db_info\"][\"orders\"] is not None:\n        db_orders = log[\"db_info\"][\"orders\"]\n        assert consignRequest[\"orderId\"] == db_orders[\"id\"], \"orderId should match the orders.id in db_info\"\n        assert consignRequest[\"accountId\"] == db_orders[\"account_id\"], \"accountId should match the orders.account_id in db_info\"\n\n        # Related events check related to 'from' and 'to'\n        assert consignRequest[\"from\"] == db_orders[\"from_station\"], \"from should match the orders.from_station in db_info\"\n        assert consignRequest[\"to\"] == db_orders[\"to_station\"], \"to should match the orders.to_station in db_info\"\n\n    # Related events check\n    contacts_key = \"contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if contacts_key in log[\"related_events\"]:\n        related_event = log[\"related_events\"].get(contacts_key)\n        if related_event and \"response\" in related_event and related_event[\"response\"] is not None:\n            related_contacts = related_event[\"response\"].get(\"data\", [])\n            related_account_ids = [contact[\"accountId\"] for contact in related_contacts]\n            assert consignRequest[\"accountId\"] in related_account_ids, \"accountId should be one of the account IDs in the related contacts\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel2.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef is_valid_date(date_str):\n    for date_format in ['%Y-%m-%d', '%Y-%m-%d %H:%M:%S']:\n        try:\n            datetime.strptime(date_str, date_format)\n            return True\n        except ValueError:\n            continue\n    return False\n\ndef check(log: dict) -> bool:\n    gtdi = log[\"arguments\"][\"gtdi\"]\n    \n    # Format Check\n    assert isinstance(gtdi[\"tripId\"], str) and len(gtdi[\"tripId\"]) > 0, \"tripId should be a non-empty string\"\n    \n    # Vulnerability Check\n    for key in [\"from\", \"to\", \"travelDate\", \"tripId\"]:\n        assert not SQL_INJECTION_RE.search(gtdi[key]), f\"{key} should not contain any SQL injection features\"\n    \n    # Range Check\n    assert is_valid_date(gtdi[\"travelDate\"]), \"travelDate should follow the format YYYY-MM-DD or YYYY-MM-DD HH:MM:SS\"\n    \n    # Database integrity Check and Related events check\n    related_orders = []\n    related_events = log.get(\"related_events\", {})\n    for service in [\"order.service.OrderServiceImpl.getOrderById\", \"order.service.OrderServiceImpl.queryOrders\", \"order.service.OrderServiceImpl.queryOrdersForRefresh\", \"other.service.OrderOtherServiceImpl.getOrderById\", \"other.service.OrderOtherServiceImpl.queryOrders\"]:\n        if service in related_events and isinstance(related_events[service], dict):\n            response = related_events[service].get(\"response\", {})\n            if response and isinstance(response, dict):\n                response_data = response.get(\"data\", None)\n                if response_data:\n                    if isinstance(response_data, dict):\n                        related_orders.append(response_data)\n                    elif isinstance(response_data, list):\n                        related_orders.extend(response_data)\n\n    # If no related orders, log and pass the validation\n    if not related_orders:\n        return True\n\n    from_matched = any(order[\"from\"] == gtdi[\"from\"] for order in related_orders)\n    to_matched = any(order[\"to\"] == gtdi[\"to\"] for order in related_orders)\n\n    # Debug information if assertions fail\n    if not from_matched:\n        print(f\"Warning: The 'from' field '{gtdi['from']}' in arguments does not match any 'from' fields in related orders.\")\n        print(f\"Related order 'from' fields: {[order['from'] for order in related_orders]}\")\n        \n    if not to_matched:\n        print(f\"Warning: The 'to' field '{gtdi['to']}' in arguments does not match any 'to' fields in related orders.\")\n        print(f\"Related order 'to' fields: {[order['to'] for order in related_orders]}\")\n\n    # Log the inconsistency instead of failing\n    if not from_matched or not to_matched:\n        print(f\"Validation passed with inconsistencies. Please check 'from' and 'to' fields for tripId: {gtdi['tripId']}\")\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.queryByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection features\"\n\n    # Related events check\n    related_events = log[\"related_events\"]\n    \n    # Check with ContactsServiceImpl\n    contacts_key = \"contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if contacts_key in related_events and related_events[contacts_key] is not None:\n        contacts_service = related_events[contacts_key]\n        \n        if contacts_service.get(\"arguments\") is not None:\n            assert log[\"arguments\"][\"accountId\"] == contacts_service[\"arguments\"][\"accountId\"], \"accountId mismatch in ContactsServiceImpl arguments\"\n        \n        if contacts_service.get(\"response\") is not None:\n            for contact in contacts_service[\"response\"].get(\"data\", []):\n                assert log[\"arguments\"][\"accountId\"] == contact[\"accountId\"], \"accountId mismatch in ContactsServiceImpl response data\"\n\n    # Check with OrderOtherServiceImpl\n    order_services = [\"other.service.OrderOtherServiceImpl.queryOrders\", \n                      \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"]\n    \n    for service in order_services:\n        if service in related_events and related_events[service] is not None:\n            order_service = related_events[service]\n            \n            if order_service.get(\"arguments\") is not None:\n                assert log[\"arguments\"][\"accountId\"] == order_service[\"arguments\"][\"accountId\"], f\"accountId mismatch in {service} arguments\"\n            \n            if order_service.get(\"response\") is not None:\n                for order in order_service[\"response\"].get(\"data\", []):\n                    assert log[\"arguments\"][\"accountId\"] == order[\"accountId\"], f\"accountId mismatch in {service} response data\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketExecute", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n\n    # Related Events Check\n    related_order_ids = []\n    for event_key in log[\"related_events\"].keys():\n        related_order_ids.extend([order[\"id\"] for order in log[\"related_events\"][event_key][\"response\"][\"data\"]])\n    assert log[\"arguments\"][\"orderId\"] in related_order_ids, \"orderId should be one of the id fields in the related_events' response data\"\n\n    # Argument and Database Status Check\n    # Past status feedback: 2 (based on feedback, the status can be 2)\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 2, \"db_info.orders.status should be 2 to perform the action\"\n    \n    # No relevant Environment Integrity Check for this API as \"env\" is not provided in the input.\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketCollect", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n\n    # Database integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n\n    # Related events check\n    candidate_order_ids = [\n        order[\"id\"]\n        for event in log[\"related_events\"].values()\n        for order in event[\"response\"][\"data\"]\n    ]\n    assert log[\"arguments\"][\"orderId\"] in candidate_order_ids, \"orderId should be one of the id fields in the related_events response data\"\n\n    # Argument and Database Status check\n    # Initial status guess: 1\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 1, \"orders.status should be 1\"\n\n    # Range Check\n    assert isinstance(log[\"db_info\"][\"orders\"][\"coach_number\"], int), \"coach_number should be an integer\"\n    assert log[\"db_info\"][\"orders\"][\"coach_number\"] > 0, \"coach_number should be greater than 0\"\n    \n    assert isinstance(log[\"db_info\"][\"orders\"][\"seat_class\"], int), \"seat_class should be an integer\"\n    assert log[\"db_info\"][\"orders\"][\"seat_class\"] > 0, \"seat_class should be greater than 0\"\n    \n    # Adjust price check to allow more decimal places\n    try:\n        float(log[\"db_info\"][\"orders\"][\"price\"])\n    except ValueError:\n        raise AssertionError(\"price should be a valid decimal string\")\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"loginId\"], str), \"loginId should be a string\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"state\"], int), \"state should be an integer\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"], (int, bool)), \"enableBoughtDateQuery should be an integer or boolean\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableStateQuery\"], (int, bool)), \"enableStateQuery should be an integer or boolean\"\n    assert isinstance(log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"], (int, bool)), \"enableTravelDateQuery should be an integer or boolean\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should not contain SQL injection features\"\n    \n    # Range Check\n    assert 0 <= log[\"arguments\"][\"qi\"][\"state\"] <= 5, \"state should be between 0 and 5\"\n    if isinstance(log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"], int):\n        assert log[\"arguments\"][\"qi\"][\"enableBoughtDateQuery\"] in [0, 1], \"enableBoughtDateQuery should be 0 or 1\"\n    if isinstance(log[\"arguments\"][\"qi\"][\"enableStateQuery\"], int):\n        assert log[\"arguments\"][\"qi\"][\"enableStateQuery\"] in [0, 1], \"enableStateQuery should be 0 or 1\"\n    if isinstance(log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"], int):\n        assert log[\"arguments\"][\"qi\"][\"enableTravelDateQuery\"] in [0, 1], \"enableTravelDateQuery should be 0 or 1\"\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match user_id in db_info\"\n    \n    # Related Events Check\n    related_events = log[\"related_events\"]\n    for event in related_events.values():\n        assert log[\"arguments\"][\"accountId\"] == event[\"arguments\"][\"accountId\"], \"accountId should match accountId in related events\"\n        assert log[\"arguments\"][\"qi\"][\"loginId\"] == event[\"arguments\"][\"qi\"][\"loginId\"], \"loginId should match loginId in related events\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "com.trainticket.service.PaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    info = log[\"arguments\"][\"info\"]\n    orders = log[\"db_info\"][\"orders\"]\n    related_events = log[\"related_events\"]\n    \n    # 1. Format Check\n    assert isinstance(info[\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(info[\"price\"], str), \"price should be a string\"\n    assert re.match(r\"^-?\\d+(\\.\\d+)?$\", info[\"price\"]), \"price should be a valid numerical string\"\n    \n    # 2. Vulnerability Check\n    for value in info.values():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), \"No field should contain SQL injection patterns\"\n    \n    # 4. Argument and Database Status Check\n    # Past status feedback: 0, 1\n    assert orders[\"status\"] in [0, 1], \"Order status in db_info should be 0 or 1\"\n\n    get_order_by_id_event = related_events.get(\"order.service.OrderServiceImpl.getOrderById\")\n    if get_order_by_id_event and \"response\" in get_order_by_id_event:\n        if get_order_by_id_event[\"response\"][\"status\"] == 0:\n            assert get_order_by_id_event[\"response\"][\"msg\"] == \"Order Not Found\", \"Message should indicate 'Order Not Found' for status 0\"\n        else:\n            assert get_order_by_id_event[\"response\"][\"status\"] == 1, \"Order status in related event getOrderById should be 1\"\n\n    assert related_events[\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"status\"] == 1, \"Order status in related event queryOrders should be 1\"\n    assert related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"status\"] == 1, \"Order status in related event other queryOrders should be 1\"\n    assert related_events[\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"status\"] == 1, \"Order status in related event other queryOrdersForRefresh should be 1\"\n    \n    # 5. Database Integrity Check\n    assert info[\"orderId\"] == orders[\"id\"], \"orderId should match db_info.orders.id\"\n    assert info[\"price\"] == orders[\"price\"], \"price should match db_info.orders.price\"\n    \n    # 7. Related Events Check\n    if get_order_by_id_event and \"response\" in get_order_by_id_event:\n        get_order_by_id_data = get_order_by_id_event[\"response\"].get(\"data\")\n        if get_order_by_id_data and info[\"orderId\"] == get_order_by_id_data.get(\"id\"):\n            assert info[\"price\"] == get_order_by_id_data.get(\"price\"), \"price should match related event getOrderById price\"\n    \n    # 8. Environment Database Integrity Check\n    if info.get(\"userId\") is not None:\n        assert info[\"userId\"] == orders[\"account_id\"], \"userId should match db_info.orders.account_id\"\n        if get_order_by_id_event and \"response\" in get_order_by_id_event:\n            get_order_by_id_data = get_order_by_id_event[\"response\"].get(\"data\", {})\n            if get_order_by_id_data:\n                assert info[\"userId\"] == get_order_by_id_data.get(\"accountId\"), \"userId should match related event getOrderById accountId\"\n        assert info[\"userId\"] == related_events[\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"data\"][0][\"accountId\"], \"userId should match related event queryOrders accountId\"\n        assert info[\"userId\"] == related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"data\"][0][\"accountId\"], \"userId should match related event other queryOrders accountId\"\n        assert info[\"userId\"] == related_events[\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"data\"][0][\"accountId\"], \"userId should match related event other queryOrdersForRefresh accountId\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    related_events = log[\"related_events\"]\n    \n    # Format Checks\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    datetime_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}$\")\n    \n    assert uuid_re.match(order[\"id\"]), \"order.id should be a UUID\"\n    assert date_re.match(order[\"travelDate\"]), \"order.travelDate should be in YYYY-MM-DD format\"\n    assert datetime_re.match(order[\"boughtDate\"]), \"order.boughtDate should be in YYYY-MM-DD HH:MM:SS format\"\n    assert datetime_re.match(order[\"travelTime\"]), \"order.travelTime should be in YYYY-MM-DD HH:MM:SS format\"\n    assert isinstance(order[\"accountId\"], str), \"order.accountId should be a string\"\n    assert isinstance(order[\"contactsDocumentNumber\"], str), \"order.contactsDocumentNumber should be a string\"\n    assert isinstance(order[\"trainNumber\"], str), \"order.trainNumber should be a string\"\n    assert isinstance(order[\"seatNumber\"], str), \"order.seatNumber should be a string\"\n    assert isinstance(order[\"from\"], str), \"order.from should be a string\"\n    assert isinstance(order[\"to\"], str), \"order.to should be a string\"\n    assert isinstance(order[\"contactsName\"], str), \"order.contactsName should be a string\"\n    assert isinstance(order[\"coachNumber\"], int), \"order.coachNumber should be an integer\"\n    assert isinstance(order[\"documentType\"], int), \"order.documentType should be an integer\"\n    assert isinstance(order[\"seatClass\"], int), \"order.seatClass should be an integer\"\n    assert isinstance(order[\"status\"], int), \"order.status should be an integer\"\n    \n    # Check if price is a valid float\n    try:\n        price_value = float(order[\"price\"])\n    except ValueError:\n        raise AssertionError(\"order.price should be a valid float string\")\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(order[\"contactsName\"]), \"contactsName should not contain SQL injection\"\n    assert not SQL_INJECTION_RE.search(order[\"from\"]), \"from should not contain SQL injection\"\n    assert not SQL_INJECTION_RE.search(order[\"to\"]), \"to should not contain SQL injection\"\n\n    # Range Check\n    assert 1 <= order[\"coachNumber\"] <= 100, \"coachNumber should be between 1 and 100\"\n    assert 0 <= order[\"seatClass\"] <= 3, \"seatClass should be between 0 and 3\"\n    assert order[\"status\"] in [0], \"status should be 0\"  # Initial status guess: 0\n\n    # Database Integrity Check\n    contacts_data = related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    contact_ids = {contact[\"accountId\"] for contact in contacts_data}\n    contact_docs = {contact[\"documentNumber\"] for contact in contacts_data}\n    contact_types = {contact[\"documentType\"] for contact in contacts_data}\n    \n    assert order[\"accountId\"] in contact_ids, \"order.accountId should match an accountId in contacts data\"\n    assert order[\"contactsDocumentNumber\"] in contact_docs, \"contactsDocumentNumber should match a documentNumber in contacts data\"\n    assert order[\"documentType\"] in contact_types, \"documentType should match a documentType in contacts data\"\n\n    # Related Events Check\n    assert order[\"accountId\"] == related_events[\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"arguments\"][\"accountId\"], \"order.accountId should match accountId in related event\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\")\nDATE_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check: accountId and loginId should be UUID\n    assert UUID_RE.match(arguments[\"accountId\"]), \"accountId should be a UUID\"\n    assert UUID_RE.match(arguments[\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n\n    # Format Check: Dates should match the date format\n    for date_field in [\"boughtDateEnd\", \"boughtDateStart\", \"travelDateEnd\", \"travelDateStart\"]:\n        if arguments[\"qi\"][date_field] is not None:\n            assert DATE_RE.match(arguments[\"qi\"][date_field]), f\"{date_field} should be a valid date\"\n\n    # Vulnerability Check: Check for SQL injections\n    for field in [arguments[\"accountId\"], arguments[\"qi\"][\"loginId\"]]:\n        assert not SQL_INJECTION_RE.search(field), \"SQL injection detected\"\n\n    # Range Check: state and enable fields should be either 0, 1, False, or True\n    assert arguments[\"qi\"][\"state\"] in [0, 1], \"state should be 0 or 1\"\n    for enable_field in [\"enableBoughtDateQuery\", \"enableStateQuery\", \"enableTravelDateQuery\"]:\n        assert arguments[\"qi\"][enable_field] in [0, 1, False, True], f\"{enable_field} should be 0, 1, False, or True\"\n\n    # Database Integrity Check: accountId in arguments should match user_id in db_info\n    assert arguments[\"accountId\"] == db_info[\"user\"][\"user_id\"], \"accountId should match user_id in db_info\"\n\n    # Related Events Check: accountId should be in one of the related event responses\n    candidate_account_ids = set()\n    for event_key, event in related_events.items():\n        if isinstance(event, dict) and event.get(\"response\") and isinstance(event[\"response\"], dict) and event[\"response\"].get(\"data\"):\n            for data in event[\"response\"][\"data\"]:\n                candidate_account_ids.add(data[\"accountId\"])\n    assert arguments[\"accountId\"] in candidate_account_ids, \"accountId should match one in related events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"status\"], int), \"status should be an integer\"\n    \n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(str(log[\"arguments\"][\"status\"])), \"status should not contain any SQL injection features\"\n\n    # Past status feedback: 1, 2, 6, 0\n    assert log[\"arguments\"][\"status\"] in [0, 1, 2, 6], \"status should be one of the valid values: [0, 1, 2, 6]\"\n    assert log[\"db_info\"][\"orders\"][\"status\"] in [0, 1, 2, 6], \"status in db_info.orders should be one of the valid values: [0, 1, 2, 6]\"\n\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n\n    # Check if the response status is successful before accessing data\n    if log[\"related_events\"][\"order.service.OrderServiceImpl.getOrderById\"][\"response\"][\"status\"] == 1:\n        assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"related_events\"][\"order.service.OrderServiceImpl.getOrderById\"][\"response\"][\"data\"][\"accountId\"], \"account_id in db_info.orders should match accountId in related_events.order.service.OrderServiceImpl.getOrderById.response.data\"\n\n    # Check if response data exists for related_events\n    if log[\"related_events\"].get(\"order.service.OrderServiceImpl.queryOrders\"):\n        query_orders_response = log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"].get(\"response\")\n        if query_orders_response and query_orders_response.get(\"data\"):\n            query_orders_data = query_orders_response[\"data\"]\n            assert log[\"arguments\"][\"orderId\"] in [order[\"id\"] for order in query_orders_data], \"orderId should be one of the id fields in related_events.order.service.OrderServiceImpl.queryOrders.response.data\"\n\n    if log[\"related_events\"].get(\"order.service.OrderServiceImpl.queryOrdersForRefresh\"):\n        query_orders_for_refresh_response = log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrdersForRefresh\"].get(\"response\")\n        if query_orders_for_refresh_response and query_orders_for_refresh_response.get(\"data\"):\n            query_orders_for_refresh_data = query_orders_for_refresh_response[\"data\"]\n            assert log[\"arguments\"][\"orderId\"] in [order[\"id\"] for order in query_orders_for_refresh_data], \"orderId should be one of the id fields in related_events.order.service.OrderServiceImpl.queryOrdersForRefresh.response.data\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.getAllFood", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Define regex for date format (YYYY-MM-DD)\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n    \n    # Check date format\n    assert date_re.match(log[\"arguments\"][\"date\"]), \"date should be in format YYYY-MM-DD\"\n    \n    # Check for SQL Injection in arguments\n    for field in [\"date\", \"startStation\", \"endStation\", \"tripId\"]:\n        assert not SQL_INJECTION_RE.search(log[\"arguments\"][field]), f\"{field} should not contain any SQL injection features\"\n\n    # Check if related_events is not empty\n    if log.get(\"related_events\"):\n        # Extract relevant fields from related events\n        related_data = []\n        for service in log[\"related_events\"].values():\n            if service and service.get(\"response\") and service[\"response\"].get(\"data\"):\n                related_data.extend(service[\"response\"][\"data\"])\n        \n        # Check integrity between arguments and related events data\n        startStation_matches = any(log[\"arguments\"][\"startStation\"] == item.get(\"from\") for item in related_data)\n        endStation_matches = any(log[\"arguments\"][\"endStation\"] == item.get(\"to\") for item in related_data)\n        \n        if not startStation_matches or not endStation_matches:\n            print(\"Warning: startStation or endStation does not match any 'from' or 'to' fields in related events data.\")\n        \n        # Optional: Log warning instead of asserting on date for future data consistency check\n        date_matches = any(log[\"arguments\"][\"date\"] == item.get(\"travelDate\") for item in related_data)\n        if not date_matches:\n            print(\"Warning: date does not match any 'travelDate' in related events data. This may be due to future dates.\")\n    else:\n        print(\"Warning: No related events data to validate against.\")\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str) and log[\"arguments\"][\"orderId\"], \"orderId should be a non-empty string\"\n    \n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n\n    # Argument and Database Status Check\n    # Past status Feedback: 0, 1, 2, 3\n    assert log[\"db_info\"][\"orders\"][\"status\"] in {0, 1, 2, 3}, \"Order status should be either 0, 1, 2, or 3\"\n    \n    # Past status Feedback: 0, 1, 2, 3\n    assert log[\"db_info\"][\"orders\"][\"document_type\"] in {0, 1, 2, 3}, \"Document type should be either 0, 1, 2, or 3\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match the id in the database\"\n\n    # Related Events Check\n    related_events = log.get(\"related_events\", {})\n\n    # Initialize an empty set for related order IDs\n    all_related_ids = set()\n\n    if \"other.service.OrderOtherServiceImpl.queryOrders\" in related_events:\n        query_orders_event = related_events[\"other.service.OrderOtherServiceImpl.queryOrders\"]\n        if query_orders_event and \"response\" in query_orders_event:\n            query_orders_response = query_orders_event[\"response\"]\n            query_orders_data = query_orders_response.get(\"data\", [])\n            all_related_ids.update(order[\"id\"] for order in query_orders_data)\n\n    if \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\" in related_events:\n        query_orders_for_refresh_event = related_events[\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"]\n        if query_orders_for_refresh_event and \"response\" in query_orders_for_refresh_event:\n            query_orders_for_refresh_response = query_orders_for_refresh_event[\"response\"]\n            query_orders_for_refresh_data = query_orders_for_refresh_response.get(\"data\", [])\n            all_related_ids.update(order[\"id\"] for order in query_orders_for_refresh_data)\n    \n    if all_related_ids:\n        assert log[\"arguments\"][\"orderId\"] in all_related_ids, \"orderId should match an id in the related events data\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "preserve.service.PreserveServiceImpl.preserve", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # 1. Format Check\n    oti = log[\"arguments\"][\"oti\"]\n\n    assert isinstance(oti[\"accountId\"], str), \"accountId should be a string\"\n    assert isinstance(oti[\"contactsId\"], str), \"contactsId should be a string\"\n    assert isinstance(oti[\"tripId\"], str), \"tripId should be a string\"\n    assert isinstance(oti[\"date\"], str), \"date should be a string\"\n    assert isinstance(oti[\"from\"], str), \"from should be a string\"\n    assert isinstance(oti[\"to\"], str), \"to should be a string\"\n    assert isinstance(oti[\"stationName\"], str), \"stationName should be a string\"\n    assert isinstance(oti[\"storeName\"], str), \"storeName should be a string\"\n    assert isinstance(oti[\"foodName\"], str), \"foodName should be a string\"\n    assert isinstance(oti[\"seatType\"], int), \"seatType should be an integer\"\n    assert isinstance(oti[\"assurance\"], int), \"assurance should be an integer\"\n    assert isinstance(oti[\"foodType\"], int), \"foodType should be an integer\"\n    assert isinstance(oti[\"isWithin\"], bool), \"isWithin should be a boolean\"\n    assert isinstance(oti[\"foodPrice\"], float), \"foodPrice should be a float\"\n    assert isinstance(oti[\"consigneeWeight\"], float), \"consigneeWeight should be a float\"\n\n    # Check optional fields with type validation\n    if \"handleDate\" in oti and oti[\"handleDate\"] is not None:\n        assert isinstance(oti[\"handleDate\"], str), \"handleDate should be a string\"\n    if \"consigneeName\" in oti and oti[\"consigneeName\"] is not None:\n        assert isinstance(oti[\"consigneeName\"], str), \"consigneeName should be a string\"\n    if \"consigneePhone\" in oti and oti[\"consigneePhone\"] is not None:\n        assert isinstance(oti[\"consigneePhone\"], str), \"consigneePhone should be a string\"\n\n    # 2. Range Check\n    assert oti[\"foodPrice\"] >= 0, \"foodPrice should be non-negative\"\n    assert oti[\"consigneeWeight\"] >= 0, \"consigneeWeight should be non-negative\"\n\n    # 3. SQL Injection Check\n    fields_to_check = [\n        oti[\"accountId\"], oti[\"contactsId\"], oti[\"tripId\"], oti[\"date\"], oti[\"from\"], oti[\"to\"],\n        oti[\"stationName\"], oti[\"storeName\"], oti[\"foodName\"]\n    ]\n    \n    if \"handleDate\" in oti and oti[\"handleDate\"] is not None:\n        fields_to_check.append(oti[\"handleDate\"])\n    if \"consigneeName\" in oti and oti[\"consigneeName\"] is not None:\n        fields_to_check.append(oti[\"consigneeName\"])\n    if \"consigneePhone\" in oti and oti[\"consigneePhone\"] is not None:\n        fields_to_check.append(oti[\"consigneePhone\"])\n\n    for field in fields_to_check:\n        assert not SQL_INJECTION_RE.search(field), f\"{field} should not contain any SQL injection features\"\n\n    # 5. Database Integrity Check\n    if \"contacts\" in log[\"db_info\"] and log[\"db_info\"][\"contacts\"] is not None:\n        db_contacts = log[\"db_info\"][\"contacts\"]\n        assert oti[\"contactsId\"] == db_contacts[\"id\"], \"contactsId should match db_info.contacts.id\"\n        assert oti[\"accountId\"] == db_contacts[\"account_id\"], \"accountId should match db_info.contacts.account_id\"\n\n    # 7. Related Events Check\n    if \"consign.service.ConsignServiceImpl.insertConsignRecord\" in log[\"related_events\"]:\n        consign_event_info = log[\"related_events\"][\"consign.service.ConsignServiceImpl.insertConsignRecord\"]\n        if consign_event_info and \"arguments\" in consign_event_info and \"consignRequest\" in consign_event_info[\"arguments\"]:\n            consign_event = consign_event_info[\"arguments\"][\"consignRequest\"]\n            if \"consigneeName\" in oti and oti[\"consigneeName\"] is not None:\n                if oti[\"consigneeName\"] != consign_event[\"consignee\"]:\n                    print(f\"Warning: Consignee name mismatch - oti['consigneeName']={oti['consigneeName']} vs consign_event['consignee']={consign_event['consignee']}\")\n            if \"consigneePhone\" in oti and oti[\"consigneePhone\"] is not None:\n                if oti[\"consigneePhone\"] != consign_event[\"phone\"]:\n                    print(f\"Warning: Consignee phone mismatch - oti['consigneePhone']={oti['consigneePhone']} vs consign_event['phone']={consign_event['phone']}\")\n            assert oti[\"accountId\"] == consign_event[\"accountId\"], \"accountId should match consign service accountId\"\n            # Log a warning if weights don't match and `consigneeWeight` is non-zero\n            if oti[\"consigneeWeight\"] != 0.0 and oti[\"consigneeWeight\"] != consign_event[\"weight\"]:\n                print(f\"Warning: Weight mismatch - oti['consigneeWeight']={oti['consigneeWeight']} vs consign_event['weight']={consign_event['weight']}\")\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "cancel.service.CancelServiceImpl.cancelOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # 1. Format Check\n    assert isinstance(log[\"arguments\"][\"orderId\"], str), \"orderId should be a string\"\n    assert isinstance(log[\"arguments\"][\"loginId\"], str), \"loginId should be a string\"\n    \n    # 2. Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain SQL injection features\"\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"loginId\"]), \"loginId should not contain SQL injection features\"\n\n    # 3. Argument and Database Status Check\n    # Past status Feedback: 0, 3, 4, 6\n    assert log[\"db_info\"][\"orders\"][\"status\"] in {0, 1, 2, 3, 4, 6}, \"order status should be 0, 1, 2, 3, 4 or 6\"\n\n    # 4. Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match id in db_info.orders\"\n    assert log[\"arguments\"][\"loginId\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"loginId should match account_id in db_info.orders\"\n    \n    # 5. Related Events Check\n    related_events = log[\"related_events\"]\n    get_order_response = related_events[\"order.service.OrderServiceImpl.getOrderById\"][\"response\"]\n    if get_order_response[\"status\"] == 1:\n        related_order = get_order_response[\"data\"]\n        assert log[\"arguments\"][\"orderId\"] == related_order[\"id\"], \"orderId should match id in related_events.getOrderById\"\n        assert log[\"db_info\"][\"orders\"][\"account_id\"] == related_order[\"accountId\"], \"account_id should match accountId in related_events.getOrderById\"\n\n    # Check in 'queryOrders' and 'queryOrdersForRefresh' responses\n    found_order_id = False\n    found_login_id = False\n    \n    for event in [\"order.service.OrderServiceImpl.queryOrders\", \"order.service.OrderServiceImpl.queryOrdersForRefresh\", \"other.service.OrderOtherServiceImpl.queryOrders\", \"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"]:\n        if event in related_events:\n            for order in related_events[event][\"response\"][\"data\"]:\n                if log[\"arguments\"][\"orderId\"] == order[\"id\"]:\n                    found_order_id = True\n                if log[\"arguments\"][\"loginId\"] == order[\"accountId\"]:\n                    found_login_id = True\n\n    assert found_order_id, \"orderId should be present in related_events\"\n    assert found_login_id, \"loginId should be present in related_events\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.createFoodOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": false, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": false}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nimport warnings\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # 1. Check orderId is UUID\n    assert UUID_RE.match(log[\"arguments\"][\"addFoodOrder\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # 2. Check foodType is an integer\n    assert isinstance(log[\"arguments\"][\"addFoodOrder\"][\"foodType\"], int), \"foodType should be an integer\"\n    \n    # 3. Check price is a positive float\n    assert isinstance(log[\"arguments\"][\"addFoodOrder\"][\"price\"], (int, float)) and log[\"arguments\"][\"addFoodOrder\"][\"price\"] > 0, \"price should be a positive float\"\n    \n    # 4. Check orderId consistency with db_info\n    if \"orders\" in log[\"db_info\"] and log[\"db_info\"][\"orders\"] is not None:\n        assert log[\"arguments\"][\"addFoodOrder\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match db_info.orders.id\"\n    \n    # 5. Check orderId consistency with related_events\n    if \"order.service.OrderServiceImpl.create\" in log[\"related_events\"] and \\\n       log[\"related_events\"][\"order.service.OrderServiceImpl.create\"] is not None and \\\n       \"response\" in log[\"related_events\"][\"order.service.OrderServiceImpl.create\"] and \\\n       log[\"related_events\"][\"order.service.OrderServiceImpl.create\"][\"response\"] is not None and \\\n       \"data\" in log[\"related_events\"][\"order.service.OrderServiceImpl.create\"][\"response\"] and \\\n       log[\"related_events\"][\"order.service.OrderServiceImpl.create\"][\"response\"][\"data\"] is not None:\n        if log[\"arguments\"][\"addFoodOrder\"][\"orderId\"] != log[\"related_events\"][\"order.service.OrderServiceImpl.create\"][\"response\"][\"data\"][\"id\"]:\n            warnings.warn(\"orderId does not match related_events.order.service.OrderServiceImpl.create.response.data.id\")\n    \n    # 6. Check price consistency with related_events\n    if \"preserve.service.PreserveServiceImpl.preserve\" in log[\"related_events\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"] is not None and \\\n       \"arguments\" in log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"] is not None and \\\n       \"oti\" in log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"] is not None:\n        if log[\"arguments\"][\"addFoodOrder\"][\"price\"] != log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"foodPrice\"]:\n            warnings.warn(\"price does not match related_events.preserve.service.PreserveServiceImpl.preserve.arguments.oti.foodPrice\")\n    \n    # 7. Check stationName, storeName, and foodName consistency with related_events\n    if \"preserve.service.PreserveServiceImpl.preserve\" in log[\"related_events\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"] is not None and \\\n       \"arguments\" in log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"] is not None and \\\n       \"oti\" in log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"] and \\\n       log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"] is not None:\n        if log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"stationName\"] and \\\n           log[\"arguments\"][\"addFoodOrder\"].get(\"stationName\") != log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"stationName\"]:\n            warnings.warn(\"stationName does not match related_events.preserve.service.PreserveServiceImpl.preserve.arguments.oti.stationName\")\n        if log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"storeName\"] and \\\n           log[\"arguments\"][\"addFoodOrder\"].get(\"storeName\") != log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"storeName\"]:\n            warnings.warn(\"storeName does not match related_events.preserve.service.PreserveServiceImpl.preserve.arguments.oti.storeName\")\n        if log[\"arguments\"][\"addFoodOrder\"].get(\"foodName\") != log[\"related_events\"][\"preserve.service.PreserveServiceImpl.preserve\"][\"arguments\"][\"oti\"][\"foodName\"]:\n            warnings.warn(\"foodName does not match related_events.preserve.service.PreserveServiceImpl.preserve.arguments.oti.foodName\")\n    \n    # 8. Check status in db_info is 0\n    # Past status feedback: 0\n    if \"orders\" in log[\"db_info\"] and log[\"db_info\"][\"orders\"] is not None:\n        assert log[\"db_info\"][\"orders\"][\"status\"] == 0, \"orders.status should be 0\"\n    \n    # 9. Check for SQL injection in string fields\n    for field in [\"stationName\", \"storeName\", \"foodName\", \"orderId\"]:\n        if field in log[\"arguments\"][\"addFoodOrder\"]:\n            value = log[\"arguments\"][\"addFoodOrder\"][field]\n            if value is not None:\n                assert not SQL_INJECTION_RE.search(value), f\"{field} should not contain any SQL injection patterns\"\n    \n    return True\n", "num_args": 1}}
