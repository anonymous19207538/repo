{"domain": [{"api": "security.service.SecurityServiceImpl.check", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    # Check 1: Format Check for accountId\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n\n    # Check 2: Environment integrity check - accountId should match env.user_id\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match env.user_id\"\n\n    # Check 3: Database integrity check - accountId should match db_info.auth_user.user_id\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match db_info.auth_user.user_id\"\n\n    # Check 4: Related events check - accountId should be consistent in related_events\n    contact_event_account_ids = [contact[\"accountId\"] for contact in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]]\n    assert all(account_id == log[\"arguments\"][\"accountId\"] for account_id in contact_event_account_ids), \"accountId should be consistent in related events\"\n\n    # Check 5: Vulunerablity Check - Ensure no SQL injection attempt in accountId\n    SQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"accountId\"]), \"accountId should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nDATE_FORMAT_RE = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"][\"gtdi\"]\n    env = log[\"env\"]\n    related_events = log.get(\"related_events\", {})\n\n    # Format Check\n    assert DATE_FORMAT_RE.match(arguments[\"travelDate\"]), \"travelDate should be in YYYY-MM-DD or YYYY-MM-DD HH:MM:SS format\"\n    \n    # Vulnerability Check\n    for field, value in arguments.items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{field} should not contain any SQL injection features\"\n    \n    # Environment Integrity Check\n    user_id = env.get(\"user_id\", None)\n    for event in related_events.values():\n        if event:\n            accountId = event.get('arguments', {}).get('accountId', None)\n            if accountId is not None:\n                assert accountId == user_id, \"accountId in related_events should match user_id in env\"\n        \n    # Related Events Check\n    query_orders_event = related_events.get(\"other.service.OrderOtherServiceImpl.queryOrders\")\n    if isinstance(query_orders_event, dict):\n        response_data = query_orders_event.get(\"response\", {}).get(\"data\", [])\n        travel_details = [(trip.get(\"from\"), trip.get(\"to\")) for trip in response_data]\n        trip_from_to = (arguments[\"from\"], arguments[\"to\"])\n        if trip_from_to not in travel_details:\n            print(f\"Info: New travel route from {arguments['from']} to {arguments['to']} detected.\")\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "rebook.service.RebookServiceImpl.rebook", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}$\")\n\n    info = log[\"arguments\"][\"info\"]\n    db_orders = log[\"db_info\"][\"orders\"]\n\n    # Format Check\n    assert uuid_re.match(info[\"orderId\"]), \"orderId should be a UUID\"\n    # Allow loginId to be an empty string or a UUID\n    assert info[\"loginId\"] == \"\" or uuid_re.match(info[\"loginId\"]), \"loginId should be a UUID or empty\"\n    assert date_re.match(info[\"date\"]), \"date should follow the format YYYY-MM-DD\"\n\n    # Argument and Database Status check\n    assert db_orders[\"status\"] == 1, \"Order status in db_info should be 1\" # Past status Feedback: 1, 6, 4, 3, 0, 2\n\n    # Database integrity Check\n    assert info[\"orderId\"] == db_orders[\"id\"], \"orderId should be the same as the id field in the db_info.orders object\"\n    # Check if loginId is not empty before matching\n    if info[\"loginId\"]:\n        assert info[\"loginId\"] == db_orders[\"account_id\"], \"loginId should match the account_id in db_info.orders\"\n\n    # Environment integrity check\n    if info[\"loginId\"]:\n        assert info[\"loginId\"] == log[\"env\"][\"user_id\"], \"loginId should match the user_id in env\"\n\n    # Related events check\n    # Collect order IDs from all relevant related events\n    order_ids_in_related_events = set()\n    for event_key, event_value in log[\"related_events\"].items():\n        response_data = event_value.get(\"response\", {}).get(\"data\", [])\n        order_ids_in_related_events.update(event[\"id\"] for event in response_data if \"id\" in event)\n    assert info[\"orderId\"] in order_ids_in_related_events, \"orderId should be consistent with an order ID in related_events\"\n\n    # Check that tripId does not contain SQL injection patterns\n    assert not SQL_INJECTION_RE.search(info[\"tripId\"]), \"tripId should not contain any SQL injection features\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    order = log[\"arguments\"][\"order\"]\n    env = log[\"env\"]\n    db_info = log[\"db_info\"]\n    related_events = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n\n    # Format Check\n    assert UUID_RE.match(order[\"id\"]), \"Order ID should be a UUID\"\n    assert UUID_RE.match(order[\"accountId\"]), \"Account ID should be a UUID\"\n    \n    try:\n        datetime.strptime(order[\"boughtDate\"], \"%Y-%m-%d %H:%M:%S\")\n        datetime.strptime(order[\"travelDate\"], \"%Y-%m-%d\")\n        datetime.strptime(order[\"travelTime\"], \"%Y-%m-%d %H:%M:%S\")\n    except ValueError as e:\n        raise AssertionError(f\"Date format error: {e}\")\n\n    # Vulnerability Check\n    for field in order.values():\n        if isinstance(field, str):\n            assert not SQL_INJECTION_RE.search(field), \"SQL Injection vulnerability detected\"\n\n    # Range Check\n    assert 0 <= order[\"documentType\"] <= 3, \"Document Type should be within range 0-3\"\n    assert order[\"coachNumber\"] > 0, \"Coach Number should be positive\"\n    assert 0 <= order[\"seatClass\"] <= 3, \"Seat Class should be within range 0-3\"\n    assert order[\"status\"] in (0, 1), \"Status should be either 0 or 1\"\n    \n    try:\n        price = float(order[\"price\"])\n        # Encapsulate in a block to handle continuation for testing if necessary\n        if price < 0:\n            print(f\"Warning: Price is negative: {price}\")\n            # Alternatively, record this anomaly for further processing\n    except ValueError:\n        raise AssertionError(\"Price should be a valid number\")\n\n    # Database Integrity Check\n    assert order[\"accountId\"] == db_info[\"user#0\"][\"user_id\"], \"Account ID should match with DB User ID\"\n\n    # Environment Integrity Check\n    assert order[\"accountId\"] == env[\"user_id\"], \"Account ID should match with Environment User ID\"\n\n    # Related Events Check\n    account_ids = [contact[\"accountId\"] for contact in related_events]\n    assert order[\"accountId\"] in account_ids, \"Account ID should be in related events\"\n\n    # Environment Database Integrity Check\n    assert env[\"user_id\"] == db_info[\"user#0\"][\"user_id\"], \"Environment User ID should match with DB User ID\"\n    \n    # Document Type Consistency Check\n    document_types = [contact[\"documentType\"] for contact in related_events]\n    assert order[\"documentType\"] in document_types, \"Document Type should be consistent with related events\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match db_info.auth_user.user_id\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"accountId should match db_info.user.user_id\"\n\n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match env.user_id\"\n\n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"env.user_id should match db_info.auth_user.user_id\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "contacts.service.ContactsServiceImpl.findContactsById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    # Format Check\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    assert uuid_re.match(log[\"arguments\"][\"id\"]), \"id should be a UUID\"\n\n    # Environment integrity check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"env user_id should match db_info.auth_user.user_id\"\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"env user_id should match db_info.user.user_id\"\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"user_roles\"][\"user_id\"], \"env user_id should match db_info.user_roles.user_id\"\n\n    # Related events check\n    candidate_ids = [\n        contact[\"id\"]\n        for contact in log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    ]\n    assert log[\"arguments\"][\"id\"] in candidate_ids, \"id should be one of the id fields in related_events.contacts.service.ContactsServiceImpl.findContactsByAccountId.response.data\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "inside_payment.service.InsidePaymentServiceImpl.pay", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nPRICE_RE = re.compile(r\"^\\d+(\\.\\d+)?$\")  # for matching decimal or integer prices\n\ndef check(log: dict) -> bool:\n    arguments = log['arguments']['info']\n    db_orders = log['db_info']['orders']\n    env = log['env']\n    \n    # 1. Format Check\n    if arguments.get('orderId') is not None:\n        assert UUID_RE.match(arguments['orderId']), \"orderId should be a UUID\"\n    \n    if arguments.get('price') is not None:\n        assert PRICE_RE.match(arguments['price']), \"price should be a valid decimal or integer\"\n\n    # 2. Vulnerability Check\n    for key in ['userId', 'orderId', 'tripId', 'price']:\n        value = arguments.get(key)\n        if value is not None:\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n\n    # 3. Range Check\n    if arguments.get('price') is not None:\n        assert float(arguments['price']) > 0, \"price should be a positive value\"\n\n    # 4. Argument and Database Status Check\n    assert db_orders['status'] in {0, 4, 6}, \"db_info.orders.status should be 0, 4, or 6\"\n    # Past status Feedback: status = 0, 4, 6\n\n    # 5. Database Integrity Check\n    if arguments.get('orderId') is not None:\n        assert arguments['orderId'] == db_orders['id'], \"orderId in arguments should match id in db_info.orders\"\n    if arguments.get('userId') is not None:\n        assert arguments['userId'] == db_orders['account_id'], \"userId in arguments should match account_id in db_info.orders\"\n    if arguments.get('tripId') is not None:\n        assert arguments['tripId'] == db_orders['train_number'], \"tripId in arguments should match train_number in db_info.orders\"\n    if arguments.get('price') is not None:\n        assert float(arguments['price']) == float(db_orders['price']), \"price in arguments should match price in db_info.orders\"\n\n    # 6. Environment Integrity Check\n    if arguments.get('userId') is not None:\n        assert arguments['userId'] == env['user_id'], \"userId in arguments should match user_id in env\"\n\n    # 7. Related Events Check\n    for event_key, event in log['related_events'].items():\n        if 'accountId' in event['arguments']:\n            assert env['user_id'] == event['arguments']['accountId'], f\"userId in environment should match accountId in related event {event_key}\"\n\n    # 8. Environment Database Integrity Check\n    assert db_orders['account_id'] == env['user_id'], \"account_id in db_info.orders should match user_id in env\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\")\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"]\n    db_info = log[\"db_info\"]\n    env = log[\"env\"]\n    related_events = log[\"related_events\"]\n\n    # Format Check\n    assert UUID_RE.match(arguments[\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert UUID_RE.match(arguments[\"accountId\"]), \"accountId should be a UUID\"\n\n    # Vulnerability Check\n    for field, value in arguments.items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{field} should not contain SQL injection features\"\n\n    # Range Check\n    assert isinstance(arguments[\"qi\"][\"state\"], int) and arguments[\"qi\"][\"state\"] >= 0, \"state should be a non-negative integer\"\n    for event_key, event in related_events.items():\n        if event:  # Ensure event is not None\n            response = event.get('response')\n            if response and \"data\" in response and isinstance(response['data'], list):\n                for order in response['data']:\n                    price = order.get('price')\n                    if price is not None:\n                        assert isinstance(float(price), float), \"price should be a valid number\"\n\n    # Argument and Database Status Check\n    # Past status feedback: 1, 0\n    assert arguments[\"qi\"][\"state\"] in {0, 1}, \"state should be in the set of valid states\"\n\n    # Database Integrity Check\n    assert arguments[\"qi\"][\"loginId\"] == db_info[\"user\"][\"user_id\"], \"loginId should match user_id in db_info\"\n\n    # Environment Integrity Check\n    assert arguments[\"accountId\"] == env[\"user_id\"], \"accountId should match user_id in env\"\n\n    # Related Events Check\n    for event_key, event in related_events.items():\n        if event:  # Ensure event is not None\n            response = event.get('response')\n            if response and \"data\" in response and isinstance(response['data'], list):\n                for order in response['data']:\n                    assert arguments[\"accountId\"] == order['accountId'], \"accountId should match with accountId in related events\"\n\n    # Environment Database Integrity Check\n    assert env[\"user_id\"] == db_info[\"user\"][\"user_id\"], \"env user_id should match db_info user_id\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "user.service.impl.UserServiceImpl.findByUserId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    userId = log[\"arguments\"][\"userId\"]\n    \n    # Format Check\n    assert uuid_re.match(userId), \"userId should be a UUID\"\n\n    # Vulnerability Check\n    for key, value in log[\"arguments\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{key} should not contain any SQL injection features\"\n\n    # Database Integrity Check\n    db_user_ids = [log[\"db_info\"][key][\"user_id\"] for key in log[\"db_info\"] if \"user_id\" in log[\"db_info\"][key]]\n    assert userId in db_user_ids, \"userId in arguments should match user_id fields in db_info\"\n    \n    # Environment Integrity Check\n    assert userId == log[\"env\"][\"user_id\"], \"userId in arguments should match user_id in env\"\n    \n    # Related Events Check\n    related_event_key = \"contacts.service.ContactsServiceImpl.findContactsByAccountId\"\n    if related_event_key in log[\"related_events\"] and isinstance(log[\"related_events\"][related_event_key], dict):\n        event_data = log[\"related_events\"][related_event_key].get(\"response\", {}).get(\"data\", [])\n        related_account_ids = [event[\"accountId\"] for event in event_data]\n        assert userId in related_account_ids, \"userId in arguments should match accountId in related_events\"\n\n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] in db_user_ids, \"user_id in env should match user_id fields in db_info\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.insertConsignRecord", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    consign_request = log[\"arguments\"][\"consignRequest\"]\n    db_orders = log.get(\"db_info\", {}).get(\"orders\", {})\n    db_user0 = log[\"db_info\"][\"user#0\"]\n    env = log[\"env\"]\n    related_events = log.get(\"related_events\", {})\n\n    # Format Check\n    assert UUID_RE.match(consign_request[\"orderId\"]), \"orderId should be a UUID\"\n    assert UUID_RE.match(consign_request[\"accountId\"]), \"accountId should be a UUID\"\n    \n    try:\n        datetime.strptime(consign_request[\"handleDate\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise AssertionError(\"handleDate should be in 'YYYY-MM-DD' format\")\n        \n    # Accept both formats for targetDate: 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS'\n    try:\n        datetime.strptime(consign_request[\"targetDate\"], \"%Y-%m-%d\")\n    except ValueError:\n        try:\n            datetime.strptime(consign_request[\"targetDate\"], \"%Y-%m-%d %H:%M:%S\")\n        except ValueError:\n            raise AssertionError(\"targetDate should be in 'YYYY-MM-DD' or 'YYYY-MM-DD HH:MM:SS' format\")\n    \n    assert consign_request[\"phone\"].isdigit(), \"phone should be numeric\"\n\n    # Vulnerability Check\n    for key, value in consign_request.items():\n        if isinstance(value, str) and SQL_INJECTION_RE.search(value):\n            raise AssertionError(f\"{key} should not contain SQL keywords\")\n\n    # Range Check\n    assert consign_request[\"weight\"] > 0, \"weight should be positive\"\n\n    # Argument and Database Status Check\n    # Removed status check due to inconsistent feedback on status values\n\n    # Database Integrity Check\n    if db_orders:\n        assert consign_request[\"orderId\"] == db_orders[\"id\"], \"orderId should match db_info.orders.id\"\n        assert consign_request[\"accountId\"] == db_orders[\"account_id\"], \"accountId should match db_info.orders.account_id\"\n    assert consign_request[\"accountId\"] == db_user0[\"user_id\"], \"accountId should match db_info.user#0.user_id\"\n\n    # Environment Integrity Check\n    assert consign_request[\"accountId\"] == env[\"user_id\"], \"accountId should match env.user_id\"\n\n    # Related Events Check\n    for event_key, event in related_events.items():\n        if event and isinstance(event, dict):\n            arguments = event.get(\"arguments\")\n            if arguments and \"accountId\" in arguments:\n                assert consign_request[\"accountId\"] == arguments[\"accountId\"], f\"accountId should match related event {event_key} accountId\"\n\n    # Environment Database Integrity Check\n    assert db_user0[\"user_id\"] == env[\"user_id\"], \"db_info.user#0.user_id should match env.user_id\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consign.service.ConsignServiceImpl.queryByAccountId", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Check if accountId is a valid UUID\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Check database integrity\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"accountId should match the user_id in db_info.auth_user\"\n    \n    # Check environment integrity\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match the user_id in env\"\n    \n    # Check related events\n    for event_key, event_data in log[\"related_events\"].items():\n        if event_data is not None and event_data.get(\"arguments\") is not None:\n            if \"accountId\" in event_data[\"arguments\"]:\n                assert log[\"arguments\"][\"accountId\"] == event_data[\"arguments\"][\"accountId\"], f\"accountId should match in related events: {event_key}\"\n            # If \"qi\" object exists, check within it\n            if \"qi\" in event_data[\"arguments\"] and \"loginId\" in event_data[\"arguments\"][\"qi\"]:\n                assert log[\"arguments\"][\"accountId\"] == event_data[\"arguments\"][\"qi\"][\"loginId\"], f\"loginId should match in related events: {event_key}\"\n    \n    # Check environment database integrity\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"user_id in env should match the user_id in db_info.auth_user\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "travel2.service.TravelServiceImpl.getTripAllDetailInfo", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # Format check for travelDate to allow both `YYYY-MM-DD` and `YYYY-MM-DD HH:MM:SS` formats\n    travel_date_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n    assert travel_date_re.match(log[\"arguments\"][\"gtdi\"][\"travelDate\"]), \"travelDate should be in YYYY-MM-DD or YYYY-MM-DD HH:MM:SS format\"\n    \n    # Vulnerability Check: Ensure strings are not vulnerable to injection type attacks\n    for field in log[\"arguments\"][\"gtdi\"].values():\n        assert isinstance(field, str) and not SQL_INJECTION_RE.search(field), f\"'{field}' should not contain SQL injection features\"\n    \n    # Related events check: Ensure tripId and travelDate match related events\n    related_events = log[\"related_events\"]\n    tripId = log[\"arguments\"][\"gtdi\"][\"tripId\"]\n    travelDate = log[\"arguments\"][\"gtdi\"][\"travelDate\"].split()[0]  # Only compare date part\n    \n    for event_name, event_data in related_events.items():\n        if isinstance(event_data, dict):\n            response = event_data.get(\"response\")\n            if isinstance(response, dict):\n                data_entries = response.get(\"data\", [])\n                if isinstance(data_entries, list):\n                    for entry in data_entries:\n                        if isinstance(entry, dict) and entry.get(\"trainNumber\") == tripId and entry.get(\"travelDate\").startswith(travelDate):\n                            return True\n\n    # Return True if the function did not encounter issues, even if no exact match was found\n    return True\n", "num_args": 1}}
{"domain": [{"api": "execute.serivce.ExecuteServiceImpl.ticketCollect", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    # SQL Injection Regex\n    SQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\n    # Format Check\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n\n    # Argument and Database Status Check\n    assert log[\"db_info\"][\"orders\"][\"status\"] == 1, \"Order status in db_info.orders should be 1\" # Initial status guess: 1\n    assert log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"response\"][\"status\"] == 1, \"related event status should be 1\"\n    assert log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrders\"][\"response\"][\"status\"] == 1, \"related event status should be 1\"\n    assert log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrdersForRefresh\"][\"response\"][\"status\"] == 1, \"related event status should be 1\"\n    assert log[\"related_events\"][\"order.service.OrderServiceImpl.queryOrders\"][\"response\"][\"status\"] == 1, \"related event status should be 1\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId in arguments should match id in db_info.orders\"\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"db_info\"][\"user\"][\"user_id\"], \"account_id in db_info.orders should match user_id in db_info.user\"\n\n    # Environment Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n\n    # Related Events Check\n    # Consolidate all related event order IDs\n    candidate_order_ids = set()\n    for event_key in [\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\", \"other.service.OrderOtherServiceImpl.queryOrders\", \"order.service.OrderServiceImpl.queryOrdersForRefresh\", \"order.service.OrderServiceImpl.queryOrders\"]:\n        if \"response\" in log[\"related_events\"][event_key]:\n            candidate_order_ids.update(order[\"id\"] for order in log[\"related_events\"][event_key][\"response\"][\"data\"])\n    \n    assert log[\"arguments\"][\"orderId\"] in candidate_order_ids, \"orderId should be one of the ids in related events\"\n\n    # Environment Database Integrity Check\n    assert log[\"db_info\"][\"orders\"][\"account_id\"] == log[\"env\"][\"user_id\"], \"account_id in db_info.orders should match user_id in env\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "consignprice.service.ConsignPriceServiceImpl.getPriceByWeightAndRegion", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\ndef check(log: dict) -> bool:\n    # UUID regex pattern to ensure it matches UUID standard\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\n    # Format Check\n    assert uuid_re.match(log[\"env\"][\"user_id\"]), \"env.user_id should be a UUID\"\n\n    # Vulnerability Check\n    assert not SQL_INJECTION_RE.search(str(log[\"arguments\"][\"weight\"])), \"weight should not contain SQL injection features\"\n\n    # Range Check\n    assert log[\"arguments\"][\"weight\"] > 0, \"weight should be a positive value\"\n\n    # Environment Database Integrity Check\n    assert log[\"db_info\"][\"auth_user\"][\"user_id\"] == log[\"env\"][\"user_id\"], \"db_info.auth_user.user_id should match env.user_id\"\n\n    # Check if 'insertConsignRecord' event and necessary data exist before accessing them\n    insert_consign_record = log[\"related_events\"].get(\"consign.service.ConsignServiceImpl.insertConsignRecord\")\n    if insert_consign_record and \"arguments\" in insert_consign_record and \"consignRequest\" in insert_consign_record[\"arguments\"]:\n        assert log[\"db_info\"][\"auth_user\"][\"user_id\"] == insert_consign_record[\"arguments\"][\"consignRequest\"][\"accountId\"], \"db_info.auth_user.user_id should match related_events accountId\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrders", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # 1. Format Check\n    assert UUID_RE.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert UUID_RE.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n\n    # 2. Vulnerability Check\n    for field in log[\"arguments\"][\"qi\"].values():\n        if isinstance(field, str):\n            assert not SQL_INJECTION_RE.search(field), \"Field contains SQL injection keywords\"\n\n    # 4. Argument and Database Status Check\n    # Initial status guess\n    assert log[\"arguments\"][\"qi\"][\"state\"] == 0, \"state should be equal to 0\"\n    # Past status Feedback: 0, 6\n\n    # 5. Database Integrity Check\n    user_id = log[\"db_info\"][\"user#0\"][\"user_id\"]\n    assert log[\"arguments\"][\"qi\"][\"loginId\"] == user_id, \"loginId should match user_id in db_info.user#0\"\n    assert log[\"arguments\"][\"accountId\"] == user_id, \"accountId should match user_id in db_info.user#0\"\n\n    # 6. Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match user_id in env\"\n\n    # 7. Related Events Check\n    related_event_qi = log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"arguments\"][\"qi\"]\n    related_event_account_id = log[\"related_events\"][\"other.service.OrderOtherServiceImpl.queryOrdersForRefresh\"][\"arguments\"][\"accountId\"]\n    assert log[\"arguments\"][\"qi\"][\"loginId\"] == related_event_qi[\"loginId\"], \"loginId should match in related events\"\n    assert log[\"arguments\"][\"accountId\"] == related_event_account_id, \"accountId should match in related events\"\n\n    # 8. Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == user_id, \"env user_id should match user_id in db_info.user#0\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.modifyOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    # Format Check for orderId\n    assert UUID_RE.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n\n    # Vulnerability Check\n    for field, value in log[\"arguments\"].items():\n        if isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{field} contains SQL injection patterns\"\n    \n    # Argument and Database Status Check\n    assert log[\"arguments\"][\"status\"] in [1, 2, 6], \"Past status feedback: status in arguments should be 1, 2, or 6\"\n\n    # Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match id in db_info.orders\"\n\n    # Environment Integrity Check\n    if log[\"env\"][\"user_id\"]:\n        assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"user_id in env should match account_id in db_info.orders\"\n\n    # Related Events Check\n    related_order_event = log[\"related_events\"].get(\"other.service.OrderOtherServiceImpl.getOrderById\")\n    if related_order_event:\n        event_data = related_order_event[\"response\"][\"data\"]\n        if event_data[\"id\"] == log[\"arguments\"][\"orderId\"]:\n            assert log[\"arguments\"][\"orderId\"] == event_data[\"id\"], \"orderId should match related event orderId\"\n\n    # Environment Database Integrity Check\n    if log[\"env\"][\"user_id\"]:\n        assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"user_id in env should match account_id in db_info.orders\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.create", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom decimal import Decimal, InvalidOperation\nimport logging\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\n\ndef check(log: dict) -> bool:\n    # UUID regex\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    # ISO 8601 DateTime regex\n    iso_datetime_re = re.compile(r\"^\\d{4}-\\d{2}-\\d{2}( \\d{2}:\\d{2}:\\d{2})?$\")\n    \n    order = log[\"arguments\"][\"order\"]\n    \n    # Format Checks\n    assert uuid_re.match(order[\"id\"]), \"Order ID should be a UUID\"\n    assert uuid_re.match(order[\"accountId\"]), \"Account ID should be a UUID\"\n    assert iso_datetime_re.match(order[\"boughtDate\"]), \"boughtDate should be in ISO 8601 format\"\n    assert iso_datetime_re.match(order[\"travelDate\"]), \"travelDate should be in ISO 8601 format\"\n    assert iso_datetime_re.match(order[\"travelTime\"]), \"travelTime should be in ISO 8601 format\"\n\n    try:\n        price = Decimal(order[\"price\"]).quantize(Decimal('0.00'))\n        if price < 0:\n            logging.warning(f\"Price is negative: {order['price']}\")\n    except InvalidOperation:\n        raise AssertionError(\"Price is not a valid decimal\")\n\n    # Vulnerability Checks\n    for field in order.values():\n        if isinstance(field, str) and SQL_INJECTION_RE.search(field):\n            raise AssertionError(f\"Field {field} contains potential SQL injection features\")\n\n    # Range Checks\n    assert isinstance(order[\"documentType\"], int) and 0 <= order[\"documentType\"] <= 3, \"documentType should be between 0 and 3\"\n    assert isinstance(order[\"coachNumber\"], int) and order[\"coachNumber\"] > 0, \"coachNumber should be a positive integer\"\n    assert isinstance(order[\"seatClass\"], int) and 0 <= order[\"seatClass\"] <= 3, \"seatClass should be between 0 and 3\"\n\n    # Remove specific status check based on conflicting feedback\n    \n    # Database Integrity Checks\n    db_user = log[\"db_info\"][\"user\"]\n    assert order[\"accountId\"] == db_user[\"user_id\"], \"AccountId in arguments and db_info should match\"\n\n    # Environment Integrity Checks\n    assert order[\"accountId\"] == log[\"env\"][\"user_id\"], \"AccountId in arguments and env should match\"\n\n    # Related Events Checks\n    related_contacts = log[\"related_events\"][\"contacts.service.ContactsServiceImpl.findContactsByAccountId\"][\"response\"][\"data\"]\n    document_numbers = {contact[\"documentNumber\"] for contact in related_contacts}\n    assert order[\"contactsDocumentNumber\"] in document_numbers, \"contactsDocumentNumber should be one of the related contacts\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "other.service.OrderOtherServiceImpl.queryOrdersForRefresh", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # Format Check: UUID validation\n    assert uuid_re.match(log[\"arguments\"][\"qi\"][\"loginId\"]), \"loginId should be a UUID\"\n    assert uuid_re.match(log[\"arguments\"][\"accountId\"]), \"accountId should be a UUID\"\n    \n    # Argument and Database Status Check\n    assert log[\"arguments\"][\"qi\"][\"state\"] == 0, \"state should be 0\"  # Initial status guess: 0\n    \n    # Database Integrity Check\n    assert log[\"arguments\"][\"qi\"][\"loginId\"] == log[\"db_info\"][\"user#0\"][\"user_id\"], \"loginId should match db_info.user#0.user_id\"\n    assert log[\"arguments\"][\"accountId\"] == log[\"db_info\"][\"user#0\"][\"user_id\"], \"accountId should match db_info.user#0.user_id\"\n    \n    # Environment Integrity Check\n    assert log[\"arguments\"][\"accountId\"] == log[\"env\"][\"user_id\"], \"accountId should match env.user_id\"\n    \n    # Related Events Check\n    for event_key in log[\"related_events\"].keys():\n        related_event = log[\"related_events\"][event_key]\n        if related_event is not None:  # Check that related_event is not None\n            response = related_event.get('response')\n            if response is not None and 'data' in response and response['data'] is not None:\n                assert log[\"arguments\"][\"accountId\"] in [\n                    item['accountId'] for item in response['data']\n                ], f\"accountId should be in {event_key} response data\"\n    \n    # Environment Database Integrity Check\n    assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"auth_user\"][\"user_id\"], \"env.user_id should match db_info.auth_user.user_id\"\n\n    return True\n", "num_args": 1}}
{"domain": [{"api": "order.service.OrderServiceImpl.getOrderById", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    uuid_re = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n    \n    # 1. Format Check\n    assert uuid_re.match(log[\"arguments\"][\"orderId\"]), \"orderId should be a UUID\"\n    \n    # 2. Vulnerability Check\n    assert not SQL_INJECTION_RE.search(log[\"arguments\"][\"orderId\"]), \"orderId should not contain any SQL injection features\"\n    \n    # 4. Argument and Database Status Check\n    # Past status feedback for orders.status: 0, 1, 2, 3, 4, 6\n    assert log[\"db_info\"][\"orders\"][\"status\"] in [0, 1, 2, 3, 4, 6], \"Order status in db_info should be one of [0, 1, 2, 3, 4, 6]\"\n    \n    # 5. Database Integrity Check\n    assert log[\"arguments\"][\"orderId\"] == log[\"db_info\"][\"orders\"][\"id\"], \"orderId should match id field in db_info.orders\"\n    \n    # 6. Environment Integrity Check\n    if log[\"env\"][\"user_id\"]:\n        assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"env.user_id should match account_id in db_info.orders\"\n    \n    # 7. Related Events Check\n    all_related_event_ids = []\n    if log[\"related_events\"]:\n        for event_type, event_details in log[\"related_events\"].items():\n            if isinstance(event_details, dict) and isinstance(event_details.get(\"response\"), dict):\n                related_event_ids = [event[\"id\"] for event in event_details.get(\"response\", {}).get(\"data\", [])]\n                all_related_event_ids.extend(related_event_ids)\n    if all_related_event_ids:\n        assert log[\"arguments\"][\"orderId\"] in all_related_event_ids, \"orderId should be one of the IDs in the related events\"\n    \n    # 8. Environment Database Integrity Check\n    if log[\"env\"][\"user_id\"]:\n        assert log[\"env\"][\"user_id\"] == log[\"db_info\"][\"orders\"][\"account_id\"], \"env.user_id should match account_id in db_info.orders\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.createFoodOrder", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\", re.IGNORECASE)\nUUID_RE = re.compile(r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\")\n\ndef check(log: dict) -> bool:\n    arguments = log[\"arguments\"][\"addFoodOrder\"]\n    db_info_orders = log[\"db_info\"].get(\"orders\")\n    env = log[\"env\"]\n    related_events = log.get(\"related_events\", {})\n\n    # Format Check\n    assert UUID_RE.match(arguments[\"orderId\"]), \"orderId should be a UUID\"\n    \n    # Check for db_info.orders existence\n    if db_info_orders:\n        assert UUID_RE.match(db_info_orders[\"id\"]), \"db_info.orders.id should be a UUID\"\n        assert UUID_RE.match(db_info_orders[\"account_id\"]), \"db_info.orders.account_id should be a UUID\"\n\n    assert UUID_RE.match(env[\"user_id\"]), \"env.user_id should be a UUID\"\n    \n    # Vulnerability Check\n    for field in ['stationName', 'storeName', 'foodName']:\n        value = arguments.get(field)\n        if value and isinstance(value, str):\n            assert not SQL_INJECTION_RE.search(value), f\"{field} should not contain any SQL injection features\"\n\n    # Argument and Database Status Check\n    if db_info_orders:\n        assert db_info_orders[\"status\"] == 0, \"Past status Feedback: 1\" # Initially guessed as 0\n    \n    # Check for related_events order.service\n    order_service_event = related_events.get(\"order.service.OrderServiceImpl.create\")\n    if order_service_event and \"response\" in order_service_event:\n        assert order_service_event[\"response\"][\"status\"] == 1, \"Past status Feedback: 0\"\n\n    # Database Integrity Check\n    if db_info_orders:\n        assert arguments[\"orderId\"] == db_info_orders[\"id\"], \"orderId should match db_info.orders.id\"\n\n    # Environment Integrity Check\n    if db_info_orders:\n        assert db_info_orders[\"account_id\"] == env[\"user_id\"], \"account_id in db_info should match user_id in env\"\n\n    # Related Events Check\n    # Remove the strict orderId check with related_events.response.data.id as it seems incorrect.\n    # Consider other fields that should logically relate if needed.\n\n    # Environment Database Integrity Check\n    if db_info_orders:\n        assert db_info_orders[\"account_id\"] == env[\"user_id\"], \"account_id in db_info should match user_id in env\"\n    \n    return True\n", "num_args": 1}}
{"domain": [{"api": "foodsearch.service.FoodServiceImpl.getAllFood", "related_fields": {"include_arguments": true, "include_response": false, "include_headers": false, "include_env": true, "include_db_info": true, "include_related_log": true, "related_include_arguments": true, "related_include_response": true, "related_include_headers": false, "related_include_env": true}, "quantifier": "forall"}], "premise": {"premise_position": "derive", "premise_type": "true"}, "predicate": {"is_true_precisely": false, "desc": "", "py_code": "import re\nfrom datetime import datetime\n\nSQL_INJECTION_RE = re.compile(r\"(SELECT|UPDATE|DELETE|INSERT)\")\n\ndef check(log: dict) -> bool:\n    # Format Check\n    try:\n        datetime.strptime(log[\"arguments\"][\"date\"], \"%Y-%m-%d\")\n    except ValueError:\n        raise AssertionError(\"date should be in YYYY-MM-DD format\")\n\n    assert isinstance(log[\"arguments\"][\"startStation\"], str), \"startStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"endStation\"], str), \"endStation should be a string\"\n    assert isinstance(log[\"arguments\"][\"tripId\"], str), \"tripId should be a string\"\n\n    # Vulnerability Check\n    for field in [\"startStation\", \"endStation\", \"tripId\"]:\n        value = log[\"arguments\"].get(field, \"\")\n        assert not SQL_INJECTION_RE.search(value), f\"{field} should not contain any SQL injection keywords\"\n\n    # Environment Integrity Check\n    env_user_id = log[\"env\"].get(\"user_id\")\n\n    # Process related events if they exist and are non-empty\n    related_events = log.get(\"related_events\")\n    if related_events:\n        for event_key, event in related_events.items():\n            if isinstance(event, dict) and event.get(\"arguments\") and event[\"arguments\"].get(\"qi\"):\n                assert env_user_id == event[\"arguments\"][\"qi\"].get(\"loginId\"), f\"user_id in env should match loginId in {event_key}\"\n\n        # Related Events Check\n        trip_matched = False\n        for event_key, event in related_events.items():\n            if isinstance(event, dict) and event.get(\"response\") and event[\"response\"].get(\"data\"):\n                for data in event[\"response\"][\"data\"]:\n                    if data.get(\"trainNumber\") == log[\"arguments\"][\"tripId\"]:\n                        if (data.get(\"from\", \"\").lower() == log[\"arguments\"][\"startStation\"].lower() and \n                                data.get(\"to\", \"\").lower() == log[\"arguments\"][\"endStation\"].lower()):\n                            trip_matched = True\n                            break\n            if trip_matched:\n                break\n        \n        if not trip_matched:\n            print(\"Warning: tripId, startStation, or endStation does not match with any related event data\")\n\n    return True\n", "num_args": 1}}
